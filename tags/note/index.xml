<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Note on Madiks&#39;s blog</title>
    <link>https://madiks.github.io/tags/note/</link>
    <description>Recent content in Note on Madiks&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 28 Jun 2017 21:12:13 +0800</lastBuildDate>
    <atom:link href="https://madiks.github.io/tags/note/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>摄影知识笔记</title>
      <link>https://madiks.github.io/post/photography-note/</link>
      <pubDate>Wed, 28 Jun 2017 21:12:13 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/photography-note/</guid>
      <description>

&lt;h3 id=&#34;摄影知识笔记&#34;&gt;摄影知识笔记&lt;/h3&gt;

&lt;h5 id=&#34;镜头-lenses&#34;&gt;镜头 Lenses&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;焦距，代表从镜头的光学中心到相机图像传感器的距离。焦距越小，镜头视角越广；焦距越大，相机取景框中呈现的物体越大。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;透视，焦距越小，镜头前近物和远物的距离越大。反之亦然。这种效果造成了远处景物变模糊。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;镜头种类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;人像镜头 60-135mm，特点是亮度好，软图像能掩盖皮肤缺陷并且能够使拍摄的物体从模糊的背景中突出显示。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;广角镜头 14-35mm，镜头涵盖的画面空间大，非常适合风景和新闻报道。鱼眼镜头是一种接近180度的广角镜头，可使画面扭曲非常像桶装。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;曝光-exposure&#34;&gt;曝光 Exposure&lt;/h5&gt;

&lt;p&gt;一定时间内到达相机传感器的光的量。&lt;/p&gt;

&lt;p&gt;曝光主要基于三个要素：光圈、快门速度、传感器的感光灵敏度ISO。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;光圈，是指镜头膜片的开口，光通过它进入相机。光圈越大，到达传感器的光越大，照片越亮。
光圈以分数的值来表示入f/2，相机中f经常被省略由简单的数字F2给出。请记住数字值约小，光圈越大。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;快门速度，是指光到达图像传感器所用的时间长度。速度越快，到达传感器的光越少。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;感光度 ISO，一般来说，ISO越高，光传感器就越敏感，图片也越亮。通常情况下ISO值最好低一点（约400），因为较高的敏感度会使图片上出现恼人的“噪点”。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在不同的外界光照环境下，通过控制这三个参数来控制画面的明暗程度。不同的搭配将会获得不同的效果，这需要自己多实践、体会。&lt;/p&gt;

&lt;h5 id=&#34;运动模糊&#34;&gt;运动模糊&lt;/h5&gt;

&lt;p&gt;快门速度不仅影响曝光，而且影响视野范围内移动对象的模糊程度。快门时间越短，捕捉图像的时间就越短，得到的帧就越轻快。反之亦然。&lt;/p&gt;

&lt;p&gt;拍摄动态场景的关键因素，曝光时间。另外长时间曝光最好使用三脚架，较少相机运动对画面的影响。&lt;/p&gt;

&lt;h5 id=&#34;景深-dof-depth-of-field&#34;&gt;景深 DOF Depth of Field&lt;/h5&gt;

&lt;p&gt;是指出现于清晰聚焦空间的前后边界之间的距离。景深就是物体最为清晰的拍摄区域。&lt;/p&gt;

&lt;p&gt;通常情况下，镜头会有一个“调焦圈”，可以用它来调节这个区域在画面的位置。景深取决于光圈的大小，光圈越大，景深越小，背景越模糊。反之亦然。&lt;/p&gt;

&lt;h5 id=&#34;白平衡-white-balance&#34;&gt;白平衡 White Balance&lt;/h5&gt;

&lt;p&gt;人脑会将看到的颜色纠正为“正常”的颜色，相机也提供这种自动纠错功能，前提是你告诉它拍摄时的光线类型。色彩纠错功能。&lt;/p&gt;

&lt;p&gt;色温值（Temperature）从1000-8000K由红（暖）变蓝（冷）。白织灯大约具有2500K的色温，略泛黄。阴影的色温7000K，颜色偏蓝。&lt;/p&gt;

&lt;p&gt;设置相机的色温值即是设置光源的色温。对于照片的彩色具有相反作用。&lt;/p&gt;

&lt;h5 id=&#34;光源&#34;&gt;光源&lt;/h5&gt;

&lt;p&gt;为光源定位和使用光源一样重要。不同位置的灯光能够以不同方式在模特和室内场景之间分配灯光。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;主光流，目的是创建主光效果，通过在照片内分配被照亮的点和阴影来进行强调。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;辅光，由于主光常常会产生大量的硬阴影和软阴影，辅光的作用就是为了“补充”这些阴影区域。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;边缘光，边缘光从后面照亮模特，突显出她的整个或部分轮廓。可以突出照片主题并使其更加丰盈。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;背景灯，背景照明就是将人物与背景分开，从而在图片中创建更加三维的外形。灯光放在主题的后面，指向背景。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;构图&#34;&gt;构图&lt;/h5&gt;

&lt;p&gt;需要自己体会&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang学习笔记</title>
      <link>https://madiks.github.io/post/golang-learn-note/</link>
      <pubDate>Wed, 03 May 2017 15:10:47 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/golang-learn-note/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;阅读&lt;a href=&#34;https://github.com/qyuhen&#34;&gt;雨痕大神&lt;/a&gt;的《Go语言学习笔记》对自己知识查漏补缺做的笔记。&lt;/p&gt;

&lt;h3 id=&#34;类型-type&#34;&gt;类型 Type&lt;/h3&gt;

&lt;p&gt;变量（variable）是一段或者多段用来存储数据的内存，类型决定了变量&lt;strong&gt;内存的长度&lt;/strong&gt;和&lt;strong&gt;存储格式&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;常量（constant）表示运行时恒定不可改变的值，使用常量的主要目的有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用一个易于阅读和理解的标识符来代替程序中的“魔法数字”&lt;/li&gt;
&lt;li&gt;在需要调整常量值的时候，无需修改所有引用代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go语言变量类型分为&lt;strong&gt;值类型&lt;/strong&gt;和&lt;strong&gt;引用类型&lt;/strong&gt;，Golang引用类型（reference type）特指slice、map、channel这三种预定义类型。&lt;/p&gt;

&lt;p&gt;内置函数new按指定类型长度分配零值内存，返回指针。并不关心类型的内部构造和初始化方式。而引用类型则必须使用make函数创建，编译器会将make转换为目标类型专用的创建函数（或指令），以确保完成全部内存分配和相关属性的初始化。&lt;/p&gt;

&lt;p&gt;当然new函数也可以为引用类型分配内存，但这是&lt;strong&gt;不完整创建&lt;/strong&gt;。以字典（dict）为例，new仅仅分配了字典类型本身（实际就是一个指针包装）所需内存，并没有分配键值对的存储内存，没有初始化散列桶的内部属性，因此它无法正常工作。&lt;/p&gt;

&lt;p&gt;自增、自减不再是运算符。只能作为独立语句，不能用于表达式。&lt;/p&gt;

&lt;p&gt;指针（pointer）与内存地址是不同的，内存地址是内存中每个字节单元的唯一编号，而指针则是一个实体。指针会分配内存空间，相当于一个专门用来保存地址的整型变量。&lt;/p&gt;

&lt;h3 id=&#34;函数-function&#34;&gt;函数 Function&lt;/h3&gt;

&lt;p&gt;函数：结构化编程的最小模块单元。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;逻辑划分、抽象、任务分解&lt;/li&gt;
&lt;li&gt;代码复用&lt;/li&gt;
&lt;li&gt;方便测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;函数调用前，会为形参和返回值分配内存空间，并将实参拷贝至形参的内存。&lt;/p&gt;

&lt;p&gt;闭包（closure）是在其词法上下文引用了自由变量的函数，或者说是函数和其引用的环境的组合体。正因为闭包通过指针引用环境中的变量，那么可能导致其生命周期延长，甚至被分配到堆内存。&lt;/p&gt;

&lt;h3 id=&#34;数据-data&#34;&gt;数据 Data&lt;/h3&gt;

&lt;p&gt;字符串是不可变字节（byte）序列，其本身是一个复合结构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type stringStruct struct {
    str unsafe.Pointer
    len int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;动态构建字符串容易引起性能问题，因为字符串是不可变字节（byte）序列，在用加法操作法拼接字符串时，每次都须重新分配内存。改进思路是预分配足够的内存。可以使用&lt;code&gt;strings.Join&lt;/code&gt;函数或者使用&lt;code&gt;bytes.Buffer&lt;/code&gt;与分配内存空间。&lt;/p&gt;

&lt;p&gt;切片（slice）本身并非动态数组或数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在制定区域内。切片本身只是一个只读对象，其工作机制类似于数组指针的一种包装。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字典（Dict）是无须键值对集合，是迭代安全的，不是并发安全的。&lt;/p&gt;

&lt;p&gt;结构体（struct）将多个不同类型的命名字段（field）序列打包成一个复合类型。&lt;/p&gt;

&lt;h3 id=&#34;方法-method&#34;&gt;方法 Method&lt;/h3&gt;

&lt;p&gt;方法是与对象实例绑定的特殊函数。receiver的类型可以是基础类型或者指针类型，主要关系到调用对象时对象实例是否会被复制。&lt;/p&gt;

&lt;p&gt;receiver类型的选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;大对象建议用*T，以减少复制成本。&lt;/li&gt;
&lt;li&gt;引用类型、字符串、函数等指针包装对象，直接用T&lt;/li&gt;
&lt;li&gt;若包含Mutex等同步字段，用*T，避免因复制造成的锁失效。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;接口-interface&#34;&gt;接口 Interface&lt;/h3&gt;

&lt;p&gt;接口代表一种调用契约，是多个方法声明的集合。&lt;/p&gt;

&lt;h3 id=&#34;并发-concurrency&#34;&gt;并发 Concurrency&lt;/h3&gt;

&lt;p&gt;关键字go创建一个并发任务单元。新建任务被放置在系统队列中，等待调度器安排合适的系统线程去执行。&lt;/p&gt;

&lt;p&gt;通道 Channel&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传输数据&lt;/li&gt;
&lt;li&gt;事件通知&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;goroutine leak是指goroutine处于发送或接收阻塞状态，但一直未被唤醒。垃圾回收器并不收集此类资源，导致它们会在等待队列里长久休眠，形成资源泄漏。&lt;/p&gt;

&lt;p&gt;通道channel和锁lock有各自不同的使用场景。通道倾向于解决逻辑层次的并发处理架构，而锁则用来保护局部范围内的数据安全。&lt;/p&gt;

&lt;h3 id=&#34;包结构&#34;&gt;包结构&lt;/h3&gt;

&lt;p&gt;内部包 Internal&lt;/p&gt;

&lt;p&gt;内部包机制相当于增加了新的访问权限控制：所有保存在internal目录下的包（包括自身）仅能被其父目录下的包（含所有层次的子目录）访问。&lt;/p&gt;

&lt;p&gt;依赖管理：vendor&lt;/p&gt;

&lt;h3 id=&#34;反射-reflect&#34;&gt;反射 Reflect&lt;/h3&gt;

&lt;p&gt;反射让我们能在运行期探知对象的类型信息和内存结构。&lt;/p&gt;

&lt;h3 id=&#34;测试-test&#34;&gt;测试 Test&lt;/h3&gt;

&lt;p&gt;单元测试用来测试逻辑算法是否符合预期外，还承担着监控代码质量的责任。代码验收和修改后的测试。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP面向对象笔记</title>
      <link>https://madiks.github.io/post/php-oop-note/</link>
      <pubDate>Mon, 23 May 2016 20:12:23 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/php-oop-note/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;阅读《PHP核心技术与最佳实践》对PHP面向对象相关知识的总结、整理与记录。&lt;/p&gt;

&lt;h3 id=&#34;面向对象-oop&#34;&gt;面向对象 OOP&lt;/h3&gt;

&lt;p&gt;面向对象程序设计（Object-Oriented Programming，OOP）是一种程序设计范性，同时也是一种程序开发方法。它将对象作为程序的基本单元，将程序和数据封装其中，以提代码的&lt;strong&gt;重用性&lt;/strong&gt;、&lt;strong&gt;灵活性&lt;/strong&gt;和&lt;strong&gt;可扩展性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;面向对象的核心思想是对象、封装、可重用和可扩展性。&lt;/p&gt;

&lt;p&gt;面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想（面向过程）刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。&lt;/p&gt;

&lt;p&gt;通常，OOP被理解为一种将程序分解为封装数据及相关操作的模块而进行的编程方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类是对象的抽象组织，对象是类的具体存在。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;php对象的本质&#34;&gt;PHP对象的本质&lt;/h3&gt;

&lt;p&gt;先看PHP5中变量的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#zend/zend.h

typedef union _zvalue_value {
    long lval; //整形
    double dval; //浮点数
    struct {
        char *val;
        int len;
    } str; //字符串
    HashTable *ht; //数组
    zend_object_value obj; //对象
} zvalue_value;

struct _zval_struct {
	/* Variable information */
	zvalue_value value;		/* value */
	zend_uint refcount__gc;
	zend_uchar type;	/* active type */
	zend_uchar is_ref__gc;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从源码可知php对象的类型是zend_object_value，接下来看它是如何实现的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#zend/zend.h

typedef struct _zend_object {
    zend_class_entry *ce; //类指针，指向对象对应的类
    HashTable *properties; //存放对象的属性表
    HashTable *guards; 
    /* protects from __get/__set ... recursion */
} zend_object;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PHP对象：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;属性数组（哈希表）&lt;/li&gt;
&lt;li&gt;类指针

&lt;ul&gt;
&lt;li&gt;类属性&lt;/li&gt;
&lt;li&gt;静态属性&lt;/li&gt;
&lt;li&gt;类常量&lt;/li&gt;
&lt;li&gt;标准方法&lt;/li&gt;
&lt;li&gt;魔术方法&lt;/li&gt;
&lt;li&gt;自定义方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对象也是一种普通的变量，不同的是其携带了对象的属性表和类的入口指针。&lt;/p&gt;

&lt;p&gt;于是可以总结PHP中对象和类的概念以及二者之间的关系：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;类是定义一系列属性和操作的模版，而对象则把属性进行具体化，然后交给类处理&lt;/li&gt;
&lt;li&gt;对象就是数据，本身不包含方法。但是对象有一个“指针”指向这个类，类里包含方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;类常量&#34;&gt;类常量&lt;/h3&gt;

&lt;p&gt;可以把在类中始终保持不变的值定义为常量。可以使用self（内部）或者类名／对象（外部）加&lt;code&gt;::&lt;/code&gt;来访问类常量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;class MyClass {
    const constant = &#39;constant value&#39;;

    function showConstant() {
        echo  self::constant . &amp;quot;\n&amp;quot;;
    }
}
var_dump(MyClass::constant);
$obj = new MyClass();
var_dump($obj::constant);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;魔术方法&#34;&gt;魔术方法&lt;/h3&gt;

&lt;p&gt;PHP魔术方法是以两个下划线&amp;rdquo;__&amp;ldquo;开头，具有特殊作用的方法。&lt;/p&gt;

&lt;p&gt;__construct() // 构造方法&lt;/p&gt;

&lt;p&gt;__destruct() // 析构方法&lt;/p&gt;

&lt;p&gt;PHP中的“重载”是指动态地创建类属性和方法：&lt;/p&gt;

&lt;p&gt;属性“重载”，当访问／设置的属性未定义／不可见时，PHP会自动调用对应的魔术方法&lt;/p&gt;

&lt;p&gt;__get($name)&lt;/p&gt;

&lt;p&gt;__set($name, $value)&lt;/p&gt;

&lt;p&gt;方法“重载”，当访问／设置的方法未定义／不可见时，PHP会自动调用对应的魔术方法，从而可以实现方法的动态创建&lt;/p&gt;

&lt;p&gt;__call($func_name, $parameters)
__callStatic($func_name, $parameters)&lt;/p&gt;

&lt;p&gt;__toString()&lt;/p&gt;

&lt;h3 id=&#34;php面向对象特性&#34;&gt;PHP面向对象特性&lt;/h3&gt;

&lt;p&gt;通常，OOP被理解为一种将程序分解为封装数据及相关操作的模块而进行的编程方式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;封装（Encapsulation），通过类来组织代码和限定数据访问权限将类与其外部世界划清界限，内外隔离来形成代码模块，让程序的结构更加清晰可理解&lt;/li&gt;
&lt;li&gt;继承（Inheritance），对类进行复用和扩展&lt;/li&gt;
&lt;li&gt;多态（Polymorphism），是指由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应。它真正的意义在于：&lt;strong&gt;实际开发中，只要关心一个接口或基类的编程，而不必关心一个对象所属的具体类&lt;/strong&gt;，同一类型（基类／接口），不同结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码复用分为继承和组合，继承是一种“是、像”的关系，而组合是一种“需要”的关系。&lt;/p&gt;

&lt;p&gt;耦合是软件结构内不同模块之间互相连接程度的度量，解耦就是要解除模块与模块间的依赖。&lt;/p&gt;

&lt;p&gt;PHP中的抽象类与接口：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;接口，多继承，只能声明 public 的方法，可以声明常量变量但不推荐这么做。接口是类与类之间的“协议”，定义了类的规范，为抽象而生。但是PHP的接口有两个不足：一是没有契约限制，使用时不做检查，二是缺少足够的内部接口。&lt;/li&gt;
&lt;li&gt;抽象类，单继承，可以声明各种类型成员变量及类常量，也可以定义非抽象方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;抽象类一般用于紧密相关的事物，而接口则用于事物的相同行为。抽象类核心是类及其行为，接口的核心是相同行为。如果必须从多个来源继承行为，就使用接口。&lt;/p&gt;

&lt;h3 id=&#34;反射-reflecton&#34;&gt;反射 Reflecton&lt;/h3&gt;

&lt;p&gt;反射，直观的理解就是根据到达地找到出发地和来源，探测类／对象的内部结构。可用于对文件里的类进行扫描来生产文档和拦截和修改方法的运行实现动态代理。&lt;/p&gt;

&lt;h3 id=&#34;异常-exception-与错误处理-error-handle&#34;&gt;异常（Exception）与错误处理（Error Handle）&lt;/h3&gt;

&lt;p&gt;PHP异常机制有不足，大部分情况无法自动抛出异常，一般只有手动抛出后才能捕获异常，但这也不影响异常机制的使用。下面三种情况会用到异常处理机制。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对程序的悲观预测，有无法预测／不可避免的情况发生&lt;/li&gt;
&lt;li&gt;程序的需要和对业务的关注，业务很重要，及早处理异常&lt;/li&gt;
&lt;li&gt;语言级别的健壮性要求，作为一种程序的补救措施及时catch和处理异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PHP错误就是会使脚本运行不正常的情况。大致的错误级别：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;deprecated&lt;/li&gt;
&lt;li&gt;notice&lt;/li&gt;
&lt;li&gt;warning&lt;/li&gt;
&lt;li&gt;fatal error&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;error_reporting — 设置应该报告何种 PHP 错误
php.ini
// 显示错误
display_errors = Off
// 记录错误日志
log_errors = On
error_log = /var/log/php_errors.log&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;error_reporting(0); // 关闭所有PHP错误报告
error_reporting(-1); // 报告所有 PHP 错误
error_reporting(E_ALL);

error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);
error_reporting(E_ALL ^ E_NOTICE); // 除了 E_NOTICE，报告其他所有错误
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接管错误和异常处理，获得更多灵活性：
set_error_handler — 设置用户自定义的错误处理函数
restore_error_handler — 还原之前的错误处理函数&lt;/p&gt;

&lt;p&gt;以下级别的错误不能由用户定义的函数来处理： E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，和在 调用 set_error_handler() 函数所在文件中产生的大多数 E_STRICT。&lt;/p&gt;

&lt;p&gt;set_exception_handler — 设置用户自定义的异常处理函数
restore_exception_handler — 恢复之前定义过的异常处理函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;mixed set_error_handler ( callable $error_handler [, int $error_types = E_ALL | E_STRICT ] )
bool restore_error_handler ( void )

callable set_exception_handler ( callable $exception_handler )
bool restore_exception_handler ( void )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;register_shutdown_function — 注册一个会在php中止时执行的函数
// 注册一个 callback ，它会在脚本执行完成或者 exit() 后被调用。&lt;/p&gt;

&lt;h3 id=&#34;面向对象设计原则&#34;&gt;面向对象设计原则&lt;/h3&gt;

&lt;p&gt;设计模式主要探讨的是类与类之间的关系。&lt;/p&gt;

&lt;p&gt;面相对象五大设计原则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单一职责原则&lt;/li&gt;
&lt;li&gt;接口隔离原则&lt;/li&gt;
&lt;li&gt;开放-封闭原则&lt;/li&gt;
&lt;li&gt;替换原则&lt;/li&gt;
&lt;li&gt;依赖倒置原则&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;单一职责原则（Single Responsibility Principle），它有两个含义：一个是避免相同的职责分散到不同的类中，另一个是避免一个类承担太多职责。可以减少耦合提高复用，是最简单也是最难做好的职责之一。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;工厂模式，根据不同参数，生成不同的实例化对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接口隔离原则（Interface Segregation Principle），一个类对另一个类的依赖性应该是建立在最小的接口上的，接口的内容应该服务于一个近似不可分割的小模块。“接口隔离”其实就是定制化服务设计的原则，服务（接口）尽量小、自成一体与外部隔离，使用多重继承实现对不同接口的组合，从而对外提供组合功能——达到“按需提供服务”。&lt;/p&gt;

&lt;p&gt;开放-封闭原则（Open-Close Principle），开放：模块的行为必须是开放的、支持扩展的，而不是僵化的。封闭：在对模块功能进行扩展时不应该影响或大规模影响已有的程序模块。概括一下就是：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。&lt;/p&gt;

&lt;p&gt;实现开放-封闭原则的核心就是&lt;strong&gt;对抽象编程&lt;/strong&gt;，而不对具体编程，因为抽象稳定。例如，让类依赖于固定的抽象类，这样的修改就是封闭的；通过面相对象的继承和多态机制，可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。具体实践中应该：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在设计方面充分应用“抽象”和“封装”思想，抽象出不变的部分将其封装成模块。&lt;/li&gt;
&lt;li&gt;在系统功能编程实现方面应用依赖抽象（抽象类／接口）的编程。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;替换原则（Liskov Substitution Principle），子类型必须能够替换掉它们的父类型、并出现在父类能够出现的任何地方。简单来说就是：子类必须能够替换成它们的基类。&lt;/p&gt;

&lt;p&gt;如何遵守该原则呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;父类的方法都要在子类中实现或者重写，并且派生类只实现其抽象类中声明的方法，而不应当给出多余的方法定义或者实现。&lt;/li&gt;
&lt;li&gt;在客户端程序中只应该使用父类对象而不应当直接使用子类对象，这样可以实现运行期绑定（动态多态）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;依赖倒置原则（Dependence Inversion Principle），简单讲就是将依赖关系倒置为依赖接口，&lt;strong&gt;依赖倒置的核心是解耦&lt;/strong&gt;，具体概念如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;上层模块不应该依赖于下层模块，它们共同依赖于一个抽象；例如：父类不能依赖子类，它们都要依赖抽象类。&lt;/li&gt;
&lt;li&gt;抽象不能依赖于具体，具体应该要依赖于抽象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其实，面相过程也好，面向对象也好，目的只有两个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;功能实现&lt;/li&gt;
&lt;li&gt;代码维护和扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;单例模式 Singleton&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只能有一个实例&lt;/li&gt;
&lt;li&gt;必须自行创建这个实例&lt;/li&gt;
&lt;li&gt;必须给其他对象提供这一实例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PHP单例模式的优缺点：虽然PHP每次执行完页面都是会从内存中清理掉所有的资源。因而PHP中的单例实际每次运行都是需要重新实例化的，但PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免（在单次请求中）大量的new操作。因为每一次new操作都会消耗系统和内存的资源。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>