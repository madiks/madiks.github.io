<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Madiks&#39;s blog</title>
    <link>https://madiks.github.io/post/</link>
    <description>Recent content in Posts on Madiks&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 07 Sep 2017 16:30:23 +0800</lastBuildDate>
    <atom:link href="https://madiks.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>记一次奇葩的面试经历</title>
      <link>https://madiks.github.io/post/a-bizarre-job-interview/</link>
      <pubDate>Thu, 07 Sep 2017 16:30:23 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/a-bizarre-job-interview/</guid>
      <description>&lt;p&gt;今天下午去某公司面试PHP岗位，经历比较奇葩，现将经历记录如下：&lt;/p&gt;

&lt;p&gt;前天下午这家公司hr给我打电话说你通过了我们的简历筛选，问我什么时候有空过去面试，于是就约了后天下午两点半的面试。&lt;/p&gt;

&lt;p&gt;今天下午两点二十我到了该公司，先从前台那领到了一张需要填写个人信息的表格，找了个地开始填表。把这张表摆在桌面上细一瞧，好家伙各种项目是列的事无巨细。从个人姓名、性别、身份证号、出生年月、籍贯、民族、政治面貌到手机号、邮箱、QQ号码、备用联系人、教育经历、获奖情况、工作年限、工作经历、上一份工作薪酬、薪酬证明人联系方式再到家庭成员关心、你爸你妈叫啥、父母年龄和工作等等信息。我自己都有点搞不清楚自己是来应聘后端程序员还是来参加政府的公务员考试的，好不容易花十多分钟填好交上去，然后等着面试。&lt;/p&gt;

&lt;p&gt;我没带简历，得等hr打出简历来才能继续面试。等了大概二十来分钟，hr带着简历来了，面试开始，我跟hr的对话如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;hr：不好意思让您久等了，咱们开始吧。&lt;/li&gt;
&lt;li&gt;我：好。&lt;/li&gt;
&lt;li&gt;hr：你是陕西人？&lt;/li&gt;
&lt;li&gt;我：对，陕西·西安的。&lt;/li&gt;
&lt;li&gt;hr：工作三年了？&lt;/li&gt;
&lt;li&gt;我：对，14年毕业的，刚好工作三年多。&lt;/li&gt;
&lt;li&gt;hr：上份工作是校招还是社招的？&lt;/li&gt;
&lt;li&gt;我：我在外地上的大学，毕业以后来北京自己找的工作。&lt;/li&gt;
&lt;li&gt;hr：那介绍一下你的项目经历吧。&lt;/li&gt;
&lt;li&gt;我：咱这是开始技术面试了吗？&lt;/li&gt;
&lt;li&gt;hr：没有，现在是hr面。&lt;/li&gt;
&lt;li&gt;我：哦，开始介绍项目经历，此处省略许多字。&lt;/li&gt;
&lt;li&gt;hr：都用过什么PHP框架？&lt;/li&gt;
&lt;li&gt;我：上架公司的项目用的是zend framework还有不用框架的项目，我自己还用过CI和laravel。&lt;/li&gt;
&lt;li&gt;hr：没用过TP？&lt;/li&gt;
&lt;li&gt;我：没用过，但是我感觉框架很快就能掌握所以没用过并不是问题。&lt;/li&gt;
&lt;li&gt;hr：……，那你上家公司项目都用什么数据库？&lt;/li&gt;
&lt;li&gt;我：Oracle，因为性能较好，能满足我们公司的业务量，后端业务逻辑不用太复杂。&lt;/li&gt;
&lt;li&gt;hr：你们没用MySQL？&lt;/li&gt;
&lt;li&gt;我：（尴尬），没用，不过我对MySQL也有一些了解。&lt;/li&gt;
&lt;li&gt;hr：那你有做管理系统和电商系统的经验吗？&lt;/li&gt;
&lt;li&gt;我：管理系统有，电商系统暂时没接触过。&lt;/li&gt;
&lt;li&gt;hr：……，介绍一下这个项目（指着简历一个项目）。&lt;/li&gt;
&lt;li&gt;我：这是我单独负责的一个爬虫项目，当时老大要抓取几个不同网站上的数据。我使用python Scrapy爬虫框架写的，抓取网页数据、整理、过滤、入库，另外的前端展示系统由其他同事负责，这项目其实比较简单。&lt;/li&gt;
&lt;li&gt;hr：python写的（简历上写的python实现）？&lt;/li&gt;
&lt;li&gt;我：对，是用python写的。&lt;/li&gt;
&lt;li&gt;hr：（少做停顿），我大概了解了你的情况。我们们公司在薪酬方面还是还是不错的，只要技术能力够薪资可以给到很高。&lt;/li&gt;
&lt;li&gt;我：（点头）。&lt;/li&gt;
&lt;li&gt;hr：现在我们公司PHP这边要招两个初级和一个高级职位，部分后端改java了，所以PHP的职位数量有些压缩。&lt;/li&gt;
&lt;li&gt;我：……（不详的预感）。&lt;/li&gt;
&lt;li&gt;hr：高级PHP岗位是要求能独立设计项目，还要带小团队做需求。你这边三年经验虽然也能满足，但是我觉得你没有电商项目相关经验，可能不适合我们。所以不好意思，麻烦你跑一趟，祝你找到更好的公司。&lt;/li&gt;
&lt;li&gt;我：……&lt;/li&gt;
&lt;li&gt;我：……&lt;/li&gt;
&lt;li&gt;我：……，那好，再见。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整个过程不到二十分钟，还没我这等面试的时间久。连对方技术的面都没见着，我就被hr否了，感觉mmp。来回折腾三小时，您这是通知我过来现场筛选简历吧，越想越生气。我就给hr回了邮件：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;希望你们写好招聘要求，做好简历筛选。技术都没面，被hr以工作经验不符拒绝，我大热天白跑一趟真的很烦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本来一肚子火，我在写邮件时还是保持了相当的克制。冷静下来觉得今天碰到这事有些搞笑，写点东西记录下来吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>摄影知识笔记</title>
      <link>https://madiks.github.io/post/photography-note/</link>
      <pubDate>Wed, 28 Jun 2017 21:12:13 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/photography-note/</guid>
      <description>

&lt;h3 id=&#34;摄影知识笔记&#34;&gt;摄影知识笔记&lt;/h3&gt;

&lt;h5 id=&#34;镜头-lenses&#34;&gt;镜头 Lenses&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;焦距，代表从镜头的光学中心到相机图像传感器的距离。焦距越小，镜头视角越广；焦距越大，相机取景框中呈现的物体越大。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;透视，焦距越小，镜头前近物和远物的距离越大。反之亦然。这种效果造成了远处景物变模糊。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;镜头种类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;人像镜头 60-135mm，特点是亮度好，软图像能掩盖皮肤缺陷并且能够使拍摄的物体从模糊的背景中突出显示。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;广角镜头 14-35mm，镜头涵盖的画面空间大，非常适合风景和新闻报道。鱼眼镜头是一种接近180度的广角镜头，可使画面扭曲非常像桶装。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;曝光-exposure&#34;&gt;曝光 Exposure&lt;/h5&gt;

&lt;p&gt;一定时间内到达相机传感器的光的量。&lt;/p&gt;

&lt;p&gt;曝光主要基于三个要素：光圈、快门速度、传感器的感光灵敏度ISO。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;光圈，是指镜头膜片的开口，光通过它进入相机。光圈越大，到达传感器的光越大，照片越亮。
光圈以分数的值来表示入f/2，相机中f经常被省略由简单的数字F2给出。请记住数字值约小，光圈越大。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;快门速度，是指光到达图像传感器所用的时间长度。速度越快，到达传感器的光越少。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;感光度 ISO，一般来说，ISO越高，光传感器就越敏感，图片也越亮。通常情况下ISO值最好低一点（约400），因为较高的敏感度会使图片上出现恼人的“噪点”。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在不同的外界光照环境下，通过控制这三个参数来控制画面的明暗程度。不同的搭配将会获得不同的效果，这需要自己多实践、体会。&lt;/p&gt;

&lt;h5 id=&#34;运动模糊&#34;&gt;运动模糊&lt;/h5&gt;

&lt;p&gt;快门速度不仅影响曝光，而且影响视野范围内移动对象的模糊程度。快门时间越短，捕捉图像的时间就越短，得到的帧就越轻快。反之亦然。&lt;/p&gt;

&lt;p&gt;拍摄动态场景的关键因素，曝光时间。另外长时间曝光最好使用三脚架，较少相机运动对画面的影响。&lt;/p&gt;

&lt;h5 id=&#34;景深-dof-depth-of-field&#34;&gt;景深 DOF Depth of Field&lt;/h5&gt;

&lt;p&gt;是指出现于清晰聚焦空间的前后边界之间的距离。景深就是物体最为清晰的拍摄区域。&lt;/p&gt;

&lt;p&gt;通常情况下，镜头会有一个“调焦圈”，可以用它来调节这个区域在画面的位置。景深取决于光圈的大小，光圈越大，景深越小，背景越模糊。反之亦然。&lt;/p&gt;

&lt;h5 id=&#34;白平衡-white-balance&#34;&gt;白平衡 White Balance&lt;/h5&gt;

&lt;p&gt;人脑会将看到的颜色纠正为“正常”的颜色，相机也提供这种自动纠错功能，前提是你告诉它拍摄时的光线类型。色彩纠错功能。&lt;/p&gt;

&lt;p&gt;色温值（Temperature）从1000-8000K由红（暖）变蓝（冷）。白织灯大约具有2500K的色温，略泛黄。阴影的色温7000K，颜色偏蓝。&lt;/p&gt;

&lt;p&gt;设置相机的色温值即是设置光源的色温。对于照片的彩色具有相反作用。&lt;/p&gt;

&lt;h5 id=&#34;光源&#34;&gt;光源&lt;/h5&gt;

&lt;p&gt;为光源定位和使用光源一样重要。不同位置的灯光能够以不同方式在模特和室内场景之间分配灯光。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;主光流，目的是创建主光效果，通过在照片内分配被照亮的点和阴影来进行强调。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;辅光，由于主光常常会产生大量的硬阴影和软阴影，辅光的作用就是为了“补充”这些阴影区域。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;边缘光，边缘光从后面照亮模特，突显出她的整个或部分轮廓。可以突出照片主题并使其更加丰盈。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;背景灯，背景照明就是将人物与背景分开，从而在图片中创建更加三维的外形。灯光放在主题的后面，指向背景。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;构图&#34;&gt;构图&lt;/h5&gt;

&lt;p&gt;需要自己体会&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>外部世界如何认识你</title>
      <link>https://madiks.github.io/post/how-world-know-you/</link>
      <pubDate>Mon, 26 Jun 2017 22:32:33 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/how-world-know-you/</guid>
      <description>

&lt;h3 id=&#34;世界与别人如何了解你&#34;&gt;世界与别人如何了解你&lt;/h3&gt;

&lt;p&gt;一些整天在接触甚至整天在使用但却被忽视的东西。&lt;/p&gt;

&lt;p&gt;your action is how the world reflect you.&lt;/p&gt;

&lt;p&gt;别人与世界对你的认识是建立在你所做的事和你的行动上的，是从特定视角观察来的。你内在的很多东西不表现出来是毫无用处的，是不能为人所知的，无法让你认识你的。&lt;/p&gt;

&lt;p&gt;所以，其实内向的人朋友少不是没有原因的：别人都没机会与你接触，也不能从你的行为来认识你，自然是没办法交朋友的。尝试开放一些，与人多交流，给别人认识你的机会。&lt;/p&gt;

&lt;p&gt;how the world know you is depend on what you have done and how you act yourself.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>对于学习的理解</title>
      <link>https://madiks.github.io/post/about-learn/</link>
      <pubDate>Mon, 22 May 2017 23:32:11 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/about-learn/</guid>
      <description>

&lt;h3 id=&#34;对于学习的理解&#34;&gt;对于学习的理解&lt;/h3&gt;

&lt;p&gt;刚读了一篇谈论学习英语方法的文章，里面介绍学习英语要在有一定基础下不断实践，小孩子牙牙学语时会的词不多但是他们面对这个新奇的世界充满好奇心，不断摸索不断实践所以成长迅速。而我们大多数人学了十几年英语反而实践的部分不如小孩子多，因而难有成效。&lt;/p&gt;

&lt;p&gt;于是我翻字典查了一下“学习”这个词的的含义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;学习：通过阅读、听讲、研究、实践等获得知识或技能的过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;汉语果然博大精深，仔细理解之下发现：学和习是不同的两个过程，要分开看待，同时做到这两者才能称之为学习。我一直以来都只是埋头读书，缺乏反复练习与使用，可以说是有学无习，难怪学完就忘，没有成效。&lt;/p&gt;

&lt;p&gt;人的认知规律是：从感性到理性，从具体到抽象，理论必须在实践中才能真正学好。而在读书时选择适合自己当前水平的书读，阅读科普书籍入门、通过学习专业教材掌握基础、通过技术书籍深入特定领域。&lt;/p&gt;

&lt;p&gt;想了一下总结出来一个学习循环♻️&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;define what to learn&lt;/li&gt;
&lt;li&gt;search,read,understand&lt;/li&gt;
&lt;li&gt;practice with real problems&lt;/li&gt;
&lt;li&gt;collect feedback, find out the missing parts&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golang学习笔记</title>
      <link>https://madiks.github.io/post/golang-learn-note/</link>
      <pubDate>Wed, 03 May 2017 15:10:47 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/golang-learn-note/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;阅读&lt;a href=&#34;https://github.com/qyuhen&#34;&gt;雨痕大神&lt;/a&gt;的《Go语言学习笔记》对自己知识查漏补缺做的笔记。&lt;/p&gt;

&lt;h3 id=&#34;类型-type&#34;&gt;类型 Type&lt;/h3&gt;

&lt;p&gt;变量（variable）是一段或者多段用来存储数据的内存，类型决定了变量&lt;strong&gt;内存的长度&lt;/strong&gt;和&lt;strong&gt;存储格式&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;常量（constant）表示运行时恒定不可改变的值，使用常量的主要目的有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用一个易于阅读和理解的标识符来代替程序中的“魔法数字”&lt;/li&gt;
&lt;li&gt;在需要调整常量值的时候，无需修改所有引用代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go语言变量类型分为&lt;strong&gt;值类型&lt;/strong&gt;和&lt;strong&gt;引用类型&lt;/strong&gt;，Golang引用类型（reference type）特指slice、map、channel这三种预定义类型。&lt;/p&gt;

&lt;p&gt;内置函数new按指定类型长度分配零值内存，返回指针。并不关心类型的内部构造和初始化方式。而引用类型则必须使用make函数创建，编译器会将make转换为目标类型专用的创建函数（或指令），以确保完成全部内存分配和相关属性的初始化。&lt;/p&gt;

&lt;p&gt;当然new函数也可以为引用类型分配内存，但这是&lt;strong&gt;不完整创建&lt;/strong&gt;。以字典（dict）为例，new仅仅分配了字典类型本身（实际就是一个指针包装）所需内存，并没有分配键值对的存储内存，没有初始化散列桶的内部属性，因此它无法正常工作。&lt;/p&gt;

&lt;p&gt;自增、自减不再是运算符。只能作为独立语句，不能用于表达式。&lt;/p&gt;

&lt;p&gt;指针（pointer）与内存地址是不同的，内存地址是内存中每个字节单元的唯一编号，而指针则是一个实体。指针会分配内存空间，相当于一个专门用来保存地址的整型变量。&lt;/p&gt;

&lt;h3 id=&#34;函数-function&#34;&gt;函数 Function&lt;/h3&gt;

&lt;p&gt;函数：结构化编程的最小模块单元。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;逻辑划分、抽象、任务分解&lt;/li&gt;
&lt;li&gt;代码复用&lt;/li&gt;
&lt;li&gt;方便测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;函数调用前，会为形参和返回值分配内存空间，并将实参拷贝至形参的内存。&lt;/p&gt;

&lt;p&gt;闭包（closure）是在其词法上下文引用了自由变量的函数，或者说是函数和其引用的环境的组合体。正因为闭包通过指针引用环境中的变量，那么可能导致其生命周期延长，甚至被分配到堆内存。&lt;/p&gt;

&lt;h3 id=&#34;数据-data&#34;&gt;数据 Data&lt;/h3&gt;

&lt;p&gt;字符串是不可变字节（byte）序列，其本身是一个复合结构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type stringStruct struct {
    str unsafe.Pointer
    len int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;动态构建字符串容易引起性能问题，因为字符串是不可变字节（byte）序列，在用加法操作法拼接字符串时，每次都须重新分配内存。改进思路是预分配足够的内存。可以使用&lt;code&gt;strings.Join&lt;/code&gt;函数或者使用&lt;code&gt;bytes.Buffer&lt;/code&gt;与分配内存空间。&lt;/p&gt;

&lt;p&gt;切片（slice）本身并非动态数组或数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在制定区域内。切片本身只是一个只读对象，其工作机制类似于数组指针的一种包装。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字典（Dict）是无须键值对集合，是迭代安全的，不是并发安全的。&lt;/p&gt;

&lt;p&gt;结构体（struct）将多个不同类型的命名字段（field）序列打包成一个复合类型。&lt;/p&gt;

&lt;h3 id=&#34;方法-method&#34;&gt;方法 Method&lt;/h3&gt;

&lt;p&gt;方法是与对象实例绑定的特殊函数。receiver的类型可以是基础类型或者指针类型，主要关系到调用对象时对象实例是否会被复制。&lt;/p&gt;

&lt;p&gt;receiver类型的选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;大对象建议用*T，以减少复制成本。&lt;/li&gt;
&lt;li&gt;引用类型、字符串、函数等指针包装对象，直接用T&lt;/li&gt;
&lt;li&gt;若包含Mutex等同步字段，用*T，避免因复制造成的锁失效。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;接口-interface&#34;&gt;接口 Interface&lt;/h3&gt;

&lt;p&gt;接口代表一种调用契约，是多个方法声明的集合。&lt;/p&gt;

&lt;h3 id=&#34;并发-concurrency&#34;&gt;并发 Concurrency&lt;/h3&gt;

&lt;p&gt;关键字go创建一个并发任务单元。新建任务被放置在系统队列中，等待调度器安排合适的系统线程去执行。&lt;/p&gt;

&lt;p&gt;通道 Channel&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传输数据&lt;/li&gt;
&lt;li&gt;事件通知&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;goroutine leak是指goroutine处于发送或接收阻塞状态，但一直未被唤醒。垃圾回收器并不收集此类资源，导致它们会在等待队列里长久休眠，形成资源泄漏。&lt;/p&gt;

&lt;p&gt;通道channel和锁lock有各自不同的使用场景。通道倾向于解决逻辑层次的并发处理架构，而锁则用来保护局部范围内的数据安全。&lt;/p&gt;

&lt;h3 id=&#34;包结构&#34;&gt;包结构&lt;/h3&gt;

&lt;p&gt;内部包 Internal&lt;/p&gt;

&lt;p&gt;内部包机制相当于增加了新的访问权限控制：所有保存在internal目录下的包（包括自身）仅能被其父目录下的包（含所有层次的子目录）访问。&lt;/p&gt;

&lt;p&gt;依赖管理：vendor&lt;/p&gt;

&lt;h3 id=&#34;反射-reflect&#34;&gt;反射 Reflect&lt;/h3&gt;

&lt;p&gt;反射让我们能在运行期探知对象的类型信息和内存结构。&lt;/p&gt;

&lt;h3 id=&#34;测试-test&#34;&gt;测试 Test&lt;/h3&gt;

&lt;p&gt;单元测试用来测试逻辑算法是否符合预期外，还承担着监控代码质量的责任。代码验收和修改后的测试。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>人生的环境论</title>
      <link>https://madiks.github.io/post/about-atmosphere/</link>
      <pubDate>Sun, 02 Apr 2017 22:52:33 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/about-atmosphere/</guid>
      <description>

&lt;h3 id=&#34;人生的环境论&#34;&gt;人生的环境论&lt;/h3&gt;

&lt;p&gt;在职业生涯中有很多因素影响自己的前进与发展，像环境、运气、机遇等超出个人控制的因素太多，想要提升个人的发展只能从可控因素下手，即做好自身相关的方面，如技术实力、解决问题的能力、做事的态度等等。&lt;/p&gt;

&lt;p&gt;我觉得个人自身自身与外界就像两个环境系统，一大一小，这俩者既有联系（大环境的变化很容易影响小环境）又有隔离（小环境的变化很难反馈到大环境或者说这种影响对大环境来说太渺小了），一个人能否成功由这两个环境系统共同决定。而个人可控的只有自我这个小环境，所以做好自己，“但行好事”才是人生成长的关键。&lt;/p&gt;

&lt;p&gt;我现在还说不好工作到底为了什么，但是工作态度已经比较明晰了：做事、做成事、解决问题。但行好事，亦问前程。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据库与sql优化</title>
      <link>https://madiks.github.io/post/sql-optimize/</link>
      <pubDate>Sat, 26 Nov 2016 23:12:13 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/sql-optimize/</guid>
      <description>

&lt;h4 id=&#34;pdo&#34;&gt;PDO&lt;/h4&gt;

&lt;p&gt;PDO提供一个数据访问的抽象层，意味着不管使用哪种数据库都可以用同样的一组API对数据进行操作，保证了可抽象性和访问接口的一致性。&lt;/p&gt;

&lt;p&gt;PDO提供了参数绑定和预编译的特性，参数绑定：数据过滤和安全，预编译：转义和软解析提速。&lt;/p&gt;

&lt;h4 id=&#34;事务&#34;&gt;事务&lt;/h4&gt;

&lt;p&gt;特性：原子性、一致性、独立性、持久性。MySQL中开启事务需要DB引擎的支持，如InnoDb.&lt;/p&gt;

&lt;h4 id=&#34;数据库优化&#34;&gt;数据库优化&lt;/h4&gt;

&lt;p&gt;分为两部分：sql语句优化和数据库服务器配置优化。&lt;/p&gt;

&lt;p&gt;sql语句优化：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;避免在列上进行运算，这样会导致索引实效。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;join时应该用小结果集驱动大结果集。同时把复杂的join查询查分成多个query。因为join多个表时，可能导致更多的锁定和堵塞。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;like模糊查询时注意避免使用%%。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;仅列出需要的字段对查询速度不会有明显影响，主要考虑节省内存。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用批量插入语句节省交互，&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;limit基数较大时使用between（只在id是连续的情况下有效）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要使用rand函数获取多条随机记录，建议先使用程序生成好随机数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;避免使用NULL&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要使用count(id)，使用count(*)/count(1)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尽可能在索引中完成排序。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用执行计划（EXPLAIN）分析优化sql语句。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;mysql的索引类型&#34;&gt;MySQL的索引类型&lt;/h4&gt;

&lt;p&gt;索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;B-Tree索引&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在B树中，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）。当数据被插入或从一个节点中移除，它的子节点数量发生变化。为了维持在预先设定的数量范围内，内部节点可能会被连结或者分离。因为子节点数量有一定的允许范围，所以B树不需要像其他自平衡查找树那样频繁地重新保持平衡，但是由于节点没有被完全填充，可能浪费了一些空间。子节点数量的上界和下界依特定的实现而设置。例如，在一个2-3 B树（通常简称2-3树），每一个内部节点只能有2或3个子节点。&lt;/p&gt;

&lt;p&gt;在Ｂ+树，这些键值的拷贝被存储在内部节点；键值和记录存储在叶子节点；另外，一个叶子节点可以包含一个指针，指向另一个叶子节点以加速顺序存取。&lt;/p&gt;

&lt;p&gt;最常见的索引类型，基于B-Tree数据结构。B-Tree的基本思想是，所有值（被索引的列）都是排过序的，每个叶节点到跟节点距离相等。所以B-Tree适合用来查找某一范围内的数据，而且可以直接支持数据排序（ORDER BY）。但是当索引多列时，列的顺序特别重要，需要格外注意。InnoDB和MyISAM都支持B-Tree索引。InnoDB用的是一个变种B+Tree，而MyISAM为了节省空间对索引进行了压缩，从而牺牲了性能。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hash索引&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基于hash表。所以这种索引只支持精确查找，不支持范围查找，不支持排序。这意味着范围查找或ORDER BY都要依赖server层的额外工作。目前只有Memory引擎支持显式的hash索引（但是它的hash是nonunique的，冲突太多时也会影响查找性能）。Memory引擎默认的索引类型即是Hash索引，虽然它也支持B-Tree索引。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Full-text索引&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;主要用来查找文本中的关键字，而不是直接与索引中的值相比较。Full-text索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的WHERE语句的参数匹配。你可以对某列分别进行full-text索引和B-Tree索引，两者互不冲突。Full-text索引配合MATCH AGAINST操作使用，而不是一般的WHERE语句加LIKE。可以在char、varchar或text类型的列上创建。&lt;/p&gt;

&lt;h4 id=&#34;字段类型&#34;&gt;字段类型&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;CHAR——字符。固定长度的字串，在右边补齐空格，达到指定的长度。支持从0到155个字符。搜索值时，后缀的空格将被删除。&lt;/li&gt;
&lt;li&gt;VARCHAR——可变长的字符。一个可变长度的字串，其中的后缀空格在存储值时被删除。支持从0到255字符&lt;/li&gt;
&lt;li&gt;TINYBLOB——微小的二进制对象。支持255个字符。需要长度+1字节的存储。与TINYTEXT一样，只不过搜索时是区分大小写的。(0.25KB)&lt;/li&gt;
&lt;li&gt;TINYTEXT——支持255个字符。要求长度+1字节的存储。与TINYBLOB一样，只不过搜索时会忽略大小写。(0.25KB)&lt;/li&gt;
&lt;li&gt;BLOB——二进制对象。支持65535个字符。需要长度+2字节的存储。 (64KB)&lt;/li&gt;
&lt;li&gt;TEXT——支持65535个字符。要求长度+2字节的存储。 (64KB)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CHAR 类型的一个变体是 VARCHAR 类型。它是一种可变长度的字符串类型，并且也必须带有一个范围在 0-255 之间的指示器。&lt;/p&gt;

&lt;p&gt;CHAR 和 VARCHGAR 不同之处在于 MYSQL 数据库处理这个指示器的方式：CHAR 把这个大小视为值的大小，不长度不足的情况下就用空格补足。而 VARCHAR 类型把它视为最大值并且只使用存储字符串实际需要的长度（增加一个额外字节来存储字符串本身的长度,需要使用额外的1个或2个字节来记录字符串的长度，小于255 只使用一个字节，大于使用2个）来存储值。所以短于指示器长度的 VARCHAR 类型不会被空格填补，但长于指示器的值仍然会被截短。&lt;/p&gt;

&lt;p&gt;因为 VARCHAR 类型可以根据实际内容动态改变存储值的长度，所以在不能确定字段需要多少字符时使用 VARCHAR 类型可以大大地节约磁盘空间、提高存储效率。但如果确切知道字符串长度,比如就在50~55之间,那就用 CHAR 因为 CHAR 类型由于本身定长的特性使其性能要高于 VARCHAR。&lt;/p&gt;

&lt;p&gt;DATETIME 和 TIMESAMP&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;都可以存储相同的数据，时间和日期&lt;/li&gt;
&lt;li&gt;TIMESAMP 只使用DATETIME一半的存储空间（4个字节与8个字节），并且根据时区变化，具有特殊的自动更新能力，但TIMESTAMP允许的时间范围小得多&lt;/li&gt;
&lt;li&gt;DATETIME 范围 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59&lt;/li&gt;
&lt;li&gt;TIMESAMP 范围 1970-01-01 08:00:01到2038-01-19 11:14:07&lt;/li&gt;
&lt;li&gt;TIMESTAMP类型在默认情况下，insert、update 数据时，TIMESTAMP列会自动以当前时间（CURRENT_TIMESTAMP）填充/更新&lt;/li&gt;
&lt;li&gt;使用INT存时间戳在业务上不方便处理的情况下，不建议使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;选择优化的数据类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更小的数据类型通常更好,它们占用更小的磁盘，内存和CPU缓存，处理时需要的CPU周期更少&lt;/li&gt;
&lt;li&gt;简单就好,整型比字符操作代价更低，因为字符集和校对规则使字符比较整型比较更复杂&lt;/li&gt;
&lt;li&gt;尽量避免NULL，查询中包含可为NULL对MYSQL来说更难优化，因为可为NULL的列使得索引、索引统计和值 比较都较为复杂&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;数据库设计&#34;&gt;数据库设计&lt;/h4&gt;

&lt;p&gt;数据库设计范式，粗略地理解为一张数据表的表结构所符合的某种设计标准的级别：&lt;/p&gt;

&lt;p&gt;第一范式，数据表中每一列都是不可分割的原子项数据且无重复的列。说明：属性不可分割。&lt;/p&gt;

&lt;p&gt;第二范式，如果依赖于主键，则需要依赖于所有主键，不能存在依赖部分主键的情况。第二范式就是要有主键，要求其他字段都依赖于主键。&lt;/p&gt;

&lt;p&gt;第三范式，属性不依赖于其它非主属性（不能依赖于非主键）。要消除传递依赖，方便理解，可以看做是“消除冗余”。&lt;/p&gt;

&lt;p&gt;范式强调数据库应该降低依赖、减少冗余、增强数据一致性。&lt;/p&gt;

&lt;p&gt;但是如今面临高并发，业务逻辑极其复杂，低延迟要求的情况，还一味固守范式是不适当的。适当降低范式、增加冗余，用空间换时间是值得的。&lt;/p&gt;

&lt;p&gt;数据库分区，就是把一张数据表的文件和索引分散存储在不同的物理文件中（甚至是硬盘中）。减少数据文件和索引文件的大小，大幅提升效率。&lt;/p&gt;

&lt;p&gt;分表，就是把原先的一张表分成几张表。进行分表查询时，可以union或者做一个视图。分表又分为垂直切分和水平切分，其中水平切分最为常用，具体可以按照用户id、时间、数据量、hash值等等来切分。（尽量按实际业务来分表，哪些字段在查询中起主要作用就按这些字段来分表）。&lt;/p&gt;

&lt;h4 id=&#34;视图&#34;&gt;视图&lt;/h4&gt;

&lt;p&gt;视图是一个虚拟表，其内容由查询定义。在MySQL中视图等价于依据sql查询语句，再处理视图时只是把视图展开成其定义的语句进行查询。&lt;/p&gt;

&lt;h4 id=&#34;sql注入&#34;&gt;SQL注入&lt;/h4&gt;

&lt;p&gt;通过构造特定的sql语句获取权限之外的数据。在原有的sql语句的基础上附加一段sql代码，构造特殊的sql语句，利用应用程序自身的权限实现所需要的操作。转义或过滤特殊字符即可防范。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP面向对象笔记</title>
      <link>https://madiks.github.io/post/php-oop-note/</link>
      <pubDate>Mon, 23 May 2016 20:12:23 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/php-oop-note/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;阅读《PHP核心技术与最佳实践》对PHP面向对象相关知识的总结、整理与记录。&lt;/p&gt;

&lt;h3 id=&#34;面向对象-oop&#34;&gt;面向对象 OOP&lt;/h3&gt;

&lt;p&gt;面向对象程序设计（Object-Oriented Programming，OOP）是一种程序设计范性，同时也是一种程序开发方法。它将对象作为程序的基本单元，将程序和数据封装其中，以提代码的&lt;strong&gt;重用性&lt;/strong&gt;、&lt;strong&gt;灵活性&lt;/strong&gt;和&lt;strong&gt;可扩展性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;面向对象的核心思想是对象、封装、可重用和可扩展性。&lt;/p&gt;

&lt;p&gt;面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想（面向过程）刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。&lt;/p&gt;

&lt;p&gt;通常，OOP被理解为一种将程序分解为封装数据及相关操作的模块而进行的编程方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类是对象的抽象组织，对象是类的具体存在。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;php对象的本质&#34;&gt;PHP对象的本质&lt;/h3&gt;

&lt;p&gt;先看PHP5中变量的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#zend/zend.h

typedef union _zvalue_value {
    long lval; //整形
    double dval; //浮点数
    struct {
        char *val;
        int len;
    } str; //字符串
    HashTable *ht; //数组
    zend_object_value obj; //对象
} zvalue_value;

struct _zval_struct {
	/* Variable information */
	zvalue_value value;		/* value */
	zend_uint refcount__gc;
	zend_uchar type;	/* active type */
	zend_uchar is_ref__gc;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从源码可知php对象的类型是zend_object_value，接下来看它是如何实现的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#zend/zend.h

typedef struct _zend_object {
    zend_class_entry *ce; //类指针，指向对象对应的类
    HashTable *properties; //存放对象的属性表
    HashTable *guards; 
    /* protects from __get/__set ... recursion */
} zend_object;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PHP对象：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;属性数组（哈希表）&lt;/li&gt;
&lt;li&gt;类指针

&lt;ul&gt;
&lt;li&gt;类属性&lt;/li&gt;
&lt;li&gt;静态属性&lt;/li&gt;
&lt;li&gt;类常量&lt;/li&gt;
&lt;li&gt;标准方法&lt;/li&gt;
&lt;li&gt;魔术方法&lt;/li&gt;
&lt;li&gt;自定义方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对象也是一种普通的变量，不同的是其携带了对象的属性表和类的入口指针。&lt;/p&gt;

&lt;p&gt;于是可以总结PHP中对象和类的概念以及二者之间的关系：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;类是定义一系列属性和操作的模版，而对象则把属性进行具体化，然后交给类处理&lt;/li&gt;
&lt;li&gt;对象就是数据，本身不包含方法。但是对象有一个“指针”指向这个类，类里包含方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;类常量&#34;&gt;类常量&lt;/h3&gt;

&lt;p&gt;可以把在类中始终保持不变的值定义为常量。可以使用self（内部）或者类名／对象（外部）加&lt;code&gt;::&lt;/code&gt;来访问类常量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;class MyClass {
    const constant = &#39;constant value&#39;;

    function showConstant() {
        echo  self::constant . &amp;quot;\n&amp;quot;;
    }
}
var_dump(MyClass::constant);
$obj = new MyClass();
var_dump($obj::constant);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;魔术方法&#34;&gt;魔术方法&lt;/h3&gt;

&lt;p&gt;PHP魔术方法是以两个下划线&amp;rdquo;__&amp;ldquo;开头，具有特殊作用的方法。&lt;/p&gt;

&lt;p&gt;__construct() // 构造方法&lt;/p&gt;

&lt;p&gt;__destruct() // 析构方法&lt;/p&gt;

&lt;p&gt;PHP中的“重载”是指动态地创建类属性和方法：&lt;/p&gt;

&lt;p&gt;属性“重载”，当访问／设置的属性未定义／不可见时，PHP会自动调用对应的魔术方法&lt;/p&gt;

&lt;p&gt;__get($name)&lt;/p&gt;

&lt;p&gt;__set($name, $value)&lt;/p&gt;

&lt;p&gt;方法“重载”，当访问／设置的方法未定义／不可见时，PHP会自动调用对应的魔术方法，从而可以实现方法的动态创建&lt;/p&gt;

&lt;p&gt;__call($func_name, $parameters)
__callStatic($func_name, $parameters)&lt;/p&gt;

&lt;p&gt;__toString()&lt;/p&gt;

&lt;h3 id=&#34;php面向对象特性&#34;&gt;PHP面向对象特性&lt;/h3&gt;

&lt;p&gt;通常，OOP被理解为一种将程序分解为封装数据及相关操作的模块而进行的编程方式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;封装（Encapsulation），通过类来组织代码和限定数据访问权限将类与其外部世界划清界限，内外隔离来形成代码模块，让程序的结构更加清晰可理解&lt;/li&gt;
&lt;li&gt;继承（Inheritance），对类进行复用和扩展&lt;/li&gt;
&lt;li&gt;多态（Polymorphism），是指由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应。它真正的意义在于：&lt;strong&gt;实际开发中，只要关心一个接口或基类的编程，而不必关心一个对象所属的具体类&lt;/strong&gt;，同一类型（基类／接口），不同结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码复用分为继承和组合，继承是一种“是、像”的关系，而组合是一种“需要”的关系。&lt;/p&gt;

&lt;p&gt;耦合是软件结构内不同模块之间互相连接程度的度量，解耦就是要解除模块与模块间的依赖。&lt;/p&gt;

&lt;p&gt;PHP中的抽象类与接口：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;接口，多继承，只能声明 public 的方法，可以声明常量变量但不推荐这么做。接口是类与类之间的“协议”，定义了类的规范，为抽象而生。但是PHP的接口有两个不足：一是没有契约限制，使用时不做检查，二是缺少足够的内部接口。&lt;/li&gt;
&lt;li&gt;抽象类，单继承，可以声明各种类型成员变量及类常量，也可以定义非抽象方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;抽象类一般用于紧密相关的事物，而接口则用于事物的相同行为。抽象类核心是类及其行为，接口的核心是相同行为。如果必须从多个来源继承行为，就使用接口。&lt;/p&gt;

&lt;h3 id=&#34;反射-reflecton&#34;&gt;反射 Reflecton&lt;/h3&gt;

&lt;p&gt;反射，直观的理解就是根据到达地找到出发地和来源，探测类／对象的内部结构。可用于对文件里的类进行扫描来生产文档和拦截和修改方法的运行实现动态代理。&lt;/p&gt;

&lt;h3 id=&#34;异常-exception-与错误处理-error-handle&#34;&gt;异常（Exception）与错误处理（Error Handle）&lt;/h3&gt;

&lt;p&gt;PHP异常机制有不足，大部分情况无法自动抛出异常，一般只有手动抛出后才能捕获异常，但这也不影响异常机制的使用。下面三种情况会用到异常处理机制。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对程序的悲观预测，有无法预测／不可避免的情况发生&lt;/li&gt;
&lt;li&gt;程序的需要和对业务的关注，业务很重要，及早处理异常&lt;/li&gt;
&lt;li&gt;语言级别的健壮性要求，作为一种程序的补救措施及时catch和处理异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PHP错误就是会使脚本运行不正常的情况。大致的错误级别：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;deprecated&lt;/li&gt;
&lt;li&gt;notice&lt;/li&gt;
&lt;li&gt;warning&lt;/li&gt;
&lt;li&gt;fatal error&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;error_reporting — 设置应该报告何种 PHP 错误
php.ini
// 显示错误
display_errors = Off
// 记录错误日志
log_errors = On
error_log = /var/log/php_errors.log&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;error_reporting(0); // 关闭所有PHP错误报告
error_reporting(-1); // 报告所有 PHP 错误
error_reporting(E_ALL);

error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);
error_reporting(E_ALL ^ E_NOTICE); // 除了 E_NOTICE，报告其他所有错误
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接管错误和异常处理，获得更多灵活性：
set_error_handler — 设置用户自定义的错误处理函数
restore_error_handler — 还原之前的错误处理函数&lt;/p&gt;

&lt;p&gt;以下级别的错误不能由用户定义的函数来处理： E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，和在 调用 set_error_handler() 函数所在文件中产生的大多数 E_STRICT。&lt;/p&gt;

&lt;p&gt;set_exception_handler — 设置用户自定义的异常处理函数
restore_exception_handler — 恢复之前定义过的异常处理函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;mixed set_error_handler ( callable $error_handler [, int $error_types = E_ALL | E_STRICT ] )
bool restore_error_handler ( void )

callable set_exception_handler ( callable $exception_handler )
bool restore_exception_handler ( void )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;register_shutdown_function — 注册一个会在php中止时执行的函数
// 注册一个 callback ，它会在脚本执行完成或者 exit() 后被调用。&lt;/p&gt;

&lt;h3 id=&#34;面向对象设计原则&#34;&gt;面向对象设计原则&lt;/h3&gt;

&lt;p&gt;设计模式主要探讨的是类与类之间的关系。&lt;/p&gt;

&lt;p&gt;面相对象五大设计原则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单一职责原则&lt;/li&gt;
&lt;li&gt;接口隔离原则&lt;/li&gt;
&lt;li&gt;开放-封闭原则&lt;/li&gt;
&lt;li&gt;替换原则&lt;/li&gt;
&lt;li&gt;依赖倒置原则&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;单一职责原则（Single Responsibility Principle），它有两个含义：一个是避免相同的职责分散到不同的类中，另一个是避免一个类承担太多职责。可以减少耦合提高复用，是最简单也是最难做好的职责之一。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;工厂模式，根据不同参数，生成不同的实例化对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接口隔离原则（Interface Segregation Principle），一个类对另一个类的依赖性应该是建立在最小的接口上的，接口的内容应该服务于一个近似不可分割的小模块。“接口隔离”其实就是定制化服务设计的原则，服务（接口）尽量小、自成一体与外部隔离，使用多重继承实现对不同接口的组合，从而对外提供组合功能——达到“按需提供服务”。&lt;/p&gt;

&lt;p&gt;开放-封闭原则（Open-Close Principle），开放：模块的行为必须是开放的、支持扩展的，而不是僵化的。封闭：在对模块功能进行扩展时不应该影响或大规模影响已有的程序模块。概括一下就是：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。&lt;/p&gt;

&lt;p&gt;实现开放-封闭原则的核心就是&lt;strong&gt;对抽象编程&lt;/strong&gt;，而不对具体编程，因为抽象稳定。例如，让类依赖于固定的抽象类，这样的修改就是封闭的；通过面相对象的继承和多态机制，可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。具体实践中应该：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在设计方面充分应用“抽象”和“封装”思想，抽象出不变的部分将其封装成模块。&lt;/li&gt;
&lt;li&gt;在系统功能编程实现方面应用依赖抽象（抽象类／接口）的编程。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;替换原则（Liskov Substitution Principle），子类型必须能够替换掉它们的父类型、并出现在父类能够出现的任何地方。简单来说就是：子类必须能够替换成它们的基类。&lt;/p&gt;

&lt;p&gt;如何遵守该原则呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;父类的方法都要在子类中实现或者重写，并且派生类只实现其抽象类中声明的方法，而不应当给出多余的方法定义或者实现。&lt;/li&gt;
&lt;li&gt;在客户端程序中只应该使用父类对象而不应当直接使用子类对象，这样可以实现运行期绑定（动态多态）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;依赖倒置原则（Dependence Inversion Principle），简单讲就是将依赖关系倒置为依赖接口，&lt;strong&gt;依赖倒置的核心是解耦&lt;/strong&gt;，具体概念如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;上层模块不应该依赖于下层模块，它们共同依赖于一个抽象；例如：父类不能依赖子类，它们都要依赖抽象类。&lt;/li&gt;
&lt;li&gt;抽象不能依赖于具体，具体应该要依赖于抽象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其实，面相过程也好，面向对象也好，目的只有两个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;功能实现&lt;/li&gt;
&lt;li&gt;代码维护和扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;单例模式 Singleton&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只能有一个实例&lt;/li&gt;
&lt;li&gt;必须自行创建这个实例&lt;/li&gt;
&lt;li&gt;必须给其他对象提供这一实例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PHP单例模式的优缺点：虽然PHP每次执行完页面都是会从内存中清理掉所有的资源。因而PHP中的单例实际每次运行都是需要重新实例化的，但PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免（在单次请求中）大量的new操作。因为每一次new操作都会消耗系统和内存的资源。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>希望始于今天</title>
      <link>https://madiks.github.io/post/hope-start-today/</link>
      <pubDate>Sat, 17 Jan 2015 10:32:11 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/hope-start-today/</guid>
      <description>&lt;p&gt;在简书上看到了一篇文章作者在文字里充满了对于现在的不满，觉得是自己过去的几年毫无作为、虚度青春造成了自己当前窘境。从文字中我能感觉到浓浓的抑郁、很压抑，我也有过这样的感觉，所以我决定劝劝他。可我从来都不是一个擅长安慰人的人，大概也就只能写写自己的经历然后跟他说，看我比你惨，别这么负面和消沉了。于是有了下面这些文字：&lt;/p&gt;

&lt;p&gt;回顾高中大学的七年，高考失败不好意思回学校见老师，大学什么都没干玩了四年游戏，校招失败。不过命运对我还是不错的，不管什么时候它都没将我逼得无路可走。我还是自己找到了一份工作，我还有很多计划和理想，其中比较现实的的一个就是出国移民。&lt;/p&gt;

&lt;p&gt;工作之后发现自己缺乏各方面的能力，从专业的基础知识，工作技能到与人沟通、交流。我现在不说自己内向了，它只是一个借口，让我变得更加自闭，情绪易波动， 懒散，没有推动力什么都不想做。虽然做着天天在与电脑打交道的工作，但我发现我不能在电脑前安静的阅读，极易分心。我现在不想老去反思自己有多失败，刚刚过去的大学四年就是对我最好的教训，当时我天天在想自己为什么这么失败，未来在哪，如果没有xx会怎么样，从这些中我除了悲伤，忧虑等负面情绪其他什么都没有得到。处于这种状态中没办法做好任何一件事，大学四年我只得到了一个比高中更坏的结果。 在工作的最初一段时间里我只期待着周末，工作日的每一天对我来说都是格外的痛苦，终于等到了周末我发现我还是感觉不到丝毫的快乐，只是对着电脑一次又一次的刷新网页，然后又期待下一个周末。我想为什么会这样，高中毕业后的我期待着大学会更好，大学时的我期待着毕业了会更好，现在毕业了我期待着明天会更好，可是明天是哪一天。想了很久我发现一直以来我都忽视今天忽视现在，我后悔的昨天曾经是我的今天，我期待的明天也将是我的今天。所以我不去想那么多了，过好今天。我现在上班挤地铁的时候会背单词，下班的时候会听英语，接受工作中的一切后发现有时候工作也还是挺有意思的。周末有时候会出去参加一下活动或者跟几个朋友吃个饭聊聊天，睡个懒觉 ，跟几个异地的朋友一起开个黑玩游戏互相嘲讽一下对方。买了一堆书，每天十几页或者几十页，不知道15年能看完几本。外部的环境没有什么改变，但我轻松了很多。过好今天，将会有一个更好的今天，我的计划列表上有很多的事，我相&lt;/p&gt;

&lt;p&gt;今天是一个周末，我睡了一个懒觉，十点多拿起手机看到简书推送的这篇文章时，突然想写一下自己，希望对你有用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>php自定义Warning的输出信息</title>
      <link>https://madiks.github.io/post/php-custom-warning-message/</link>
      <pubDate>Tue, 30 Dec 2014 21:10:40 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/php-custom-warning-message/</guid>
      <description>

&lt;h3 id=&#34;php自定义warning的输出信息&#34;&gt;php自定义Warning的输出信息&lt;/h3&gt;

&lt;p&gt;前几天公司平台接入了新的合作商，数据抓取服务一直没问题，到今天有一本书一直报错，查看log发现Warning,出错是由于导致xml解析错误。想到输出一下具体的bookid和chapter_id来查看到底是哪本书哪个章节的问题。&lt;/p&gt;

&lt;p&gt;直接想到的方案是try catch在出错的时候输出bookid和chapter_id,但是发现php try catch无法处理Warning错误，于是Google了php如何catch warning，在stackoverflow上找到了如下方法：
&lt;a href=&#34;http://stackoverflow.com/questions/1241728/can-i-try-catch-a-warning&#34;&gt;http://stackoverflow.com/questions/1241728/can-i-try-catch-a-warning&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;大致是通过 set_error_handler来自定义处理Warning的方法，在其中抛出一个异常然后再try catch它输出bookid和chapter_id，基本照抄给的实例于是如下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;set_error_handler(function($errno, $errstr, $errfile, $errline, array $errcontext) {
  // error was suppressed with the @-operator
     if (0 === error_reporting()) {
         return false;
     }
     throw new ErrorException($errstr, 0, $errno, $errfile, $errline);
}, E_WARNING);
try{
  $chapter_content = simplexml_load_string($chaptercontent_xml);
} catch (Exception $e) {
    echo &amp;quot;Caught exception: bookid = $id , chapter_id = $chapter_id &amp;quot;,  $e-&amp;gt;getMessage(), &amp;quot;\n&amp;quot;;
    exit();
}
restore_error_handler();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释：使用set_error_handler来接管warning的处理，在其回调函数中抛出一个Exception,然后就可以try catch了，最后调用restore_error_handler();来撤销你设置的error_handler从而使其不影响后续的代码。&lt;/p&gt;

&lt;p&gt;思考：这样改完后确实得到了bookid和chapter_id，但是有没有别的更简单方法来实现，其实我最本质的需求就是要自定义输出的Warning消息使其在输出错误的时候带上bookid和chapter_id上面的方法虽然解决了这个问题但是绕了一个大圈。查看php手册上set_error_handler的详细用法发现：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;handler的第五个可选参数，errcontext， 是一个指向错误发生时活动符号表的 array。 也就是说，errcontext 会包含错误触发处作用域内所有变量的数组。 用户的错误处理程序不应该修改错误上下文（context）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们在此处直接用errcontext直接输出要的信息即可，于是有了下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;set_error_handler(function($errno, $errstr, $errfile, $errline, array $errcontext){
  // error was suppressed with the @-operator
  if (0 === error_reporting()) {
     return false;
  }
  echo &amp;quot;Caught Waring:bookid=$errcontext[bookid],chapter_id=$errcontext[chapter_id] Waring Message:&amp;quot;,$errstr,&#39; in &#39;,$errfile,&#39; on line &#39;,$errline,&amp;quot;\n&amp;quot;;
}, E_WARNING);
$chapter_content = simplexml_load_string($chaptercontent_xml);
restore_error_handler();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释：直接在set_error_handler组织和输出错误信息即可完成自定义Warning错误信息的输出，这样简单了很多，加上这段代码后以后如果出问题直接去log里面查找就可拿到所需的信息，定位到问题所在。&lt;/p&gt;

&lt;p&gt;总结：在解决完一个问题是最好多想想这个问题的本质，有没有更好的解决方案，这才能不断进步。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>我在创业团队实习收获</title>
      <link>https://madiks.github.io/post/internship-at-startups/</link>
      <pubDate>Sat, 22 Mar 2014 21:12:41 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/internship-at-startups/</guid>
      <description>

&lt;h3 id=&#34;我在创业团队实习收获&#34;&gt;我在创业团队实习收获&lt;/h3&gt;

&lt;p&gt;去年12月到今年3月初在一本地软件公司进行PHP实习，分到该公司的创业部门。为什么说是创业部门呢，原来该公司主要从事政府部门的软件、网站的设计，可能是老总想要发展新的赢利点吧，于是公司就成立了一个创业部门发展新业务，选择的方向也是前端时间比较热门的微信公众平台的开发。&lt;/p&gt;

&lt;p&gt;我刚进入该部门的时候，这个项目已经开始了大约一个月，然后直到今年三月初的项目失败以后博主就离开了这家公司，期间经历了比较多的事，有很多的收获。先感谢这家公司给我的实习机会，下面就开始列一列我的实习感受和一些总结，写的比较乱没有什么章法，有对有错，大家凑合看吧。&lt;/p&gt;

&lt;h5 id=&#34;产品方面&#34;&gt;产品方面：&lt;/h5&gt;

&lt;p&gt;1.创业期间产品线不能太广，要把握核心业务，迅速建立核心业务原型，让基础（核心）业务良好运行之后再慢慢的“做加法”，在初期一定要把有限的资源用在最需要的地方。&lt;/p&gt;

&lt;p&gt;2.不要随意切换项目，要把当前的项目完成或者彻底放弃&lt;/p&gt;

&lt;p&gt;3.所谓创业团队(尤其是小规模创业团队)就是一定要目标明确、单一、可执行。&lt;/p&gt;

&lt;p&gt;这就是博主离开的原因，在这个项目失败以后，我们部门又在寻找新的项目，从本地服务门户到社交、团购、问答都考虑了一遍，后来大体确定要做一个覆盖大量用户的以话题为中心的大型社交型本地社区，我也理解的不是很明白，所以表达的也不是很明白。我觉得太靠谱就选择了离开，总之祝他们好运，能够成功。&lt;/p&gt;

&lt;h5 id=&#34;团队方面&#34;&gt;团队方面:&lt;/h5&gt;

&lt;p&gt;4.创业团队人员结构要合理，要有核心成员，团队要精简，每一个人都有用武之地&lt;/p&gt;

&lt;p&gt;5.不空谈理想，畅想未来，或者团队文化，太假大空的东西会让人觉得不靠谱&lt;/p&gt;

&lt;p&gt;6.在项目开发的初期，大量进行人员调整是大忌，会直接引起团队内情绪低落，对项目失去信心。所以不管是主动离职还是辞退都要尽量避免，一旦发生这种情况，要及时说明做好团队成员的心理工作。更好的方法是在团队建立的时候吸纳人员的时候，严格把控，从而避免这种情况。&lt;/p&gt;

&lt;h5 id=&#34;编码方面&#34;&gt;编码方面：&lt;/h5&gt;

&lt;p&gt;7.一定要有注释，哪怕比较简单的结构也要留下必要的注释&lt;/p&gt;

&lt;p&gt;以前我不太相信自己写的代码自己能读不懂，在这个项目的时候我是真遇到了，一个月前我写的代码可我就是不认识它，这个后悔啊，当时我哪怕留下一句注释都好啊。唉说多了都是泪，积累经验了。(这段其实是自己的问题，自己的代码自己不认识不是因为没加注释而是因为自己没懂，只是粗略的写完而没有去理清自己的思路加上代码的可读性差所以会造成这种情况，跟加不加注释关系不大，有良好风格的代码本身就能起到注释的作用。)
8.设计稍微复杂的功能模块一定要在纸上建立业务流程和逻辑顺序，切记想到哪写到哪，这样可能会留下一些莫名其妙的bug&lt;/p&gt;

&lt;p&gt;这个也有体会，当时让我写的一个小模块出了些莫名其妙的bug，我去检查的时候读我写的代码，发现逻辑极其混乱，毫无章法再加上没留注释，完全搞不明白自己当时想干啥，后来直接删掉重写了，太坑了。&lt;/p&gt;

&lt;h5 id=&#34;做项目-学习-方面&#34;&gt;做项目（学习）方面：&lt;/h5&gt;

&lt;p&gt;9.把握程序的核心结构和功能来学习，掌握核心的东西，每一个项目都要总结收获&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>