<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Php on Madiks&#39;s blog</title>
    <link>https://madiks.github.io/categories/php/</link>
    <description>Recent content in Php on Madiks&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 27 Sep 2017 21:22:14 +0800</lastBuildDate>
    <atom:link href="https://madiks.github.io/categories/php/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>从零搭建LNMP开发环境</title>
      <link>https://madiks.github.io/post/build-vagrant-lnmp-sde/</link>
      <pubDate>Wed, 27 Sep 2017 21:22:14 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/build-vagrant-lnmp-sde/</guid>
      <description>

&lt;p&gt;在Mac从零搭建PHP7开发环境，由于我不想直接在本地环境下直接操作所以使用Vagrant+VirtualBox在虚拟机来搭建开发环境，这样可以不用考虑开发环境各种配置对于本机的影响。&lt;/p&gt;

&lt;p&gt;关于Vagrant可以参考这两篇文章：&lt;a href=&#34;http://www.ituring.com.cn/article/131600&#34;&gt;为什么要使用Vagrant&lt;/a&gt;和&lt;a href=&#34;https://segmentfault.com/a/1190000000264347&#34;&gt;Vagrant使用简介&lt;/a&gt;我就不多做解释了。&lt;/p&gt;

&lt;p&gt;如果你不想自己手动搭建整个环境可以直接使用&lt;a href=&#34;https://github.com/laravel/homestead&#34;&gt;Laravel Homestead&lt;/a&gt;，这是由Laravel框架开发者提供的一个已搭建好的跨平台（Windows、 Mac、 Linux）的PHP开发环境，内置了如Nginx、PHP7、 MySQL、 Postgres、 Redis、 Memcached、 Node等服务，只需在Vagrant下载入box文件做到了开箱即用。&lt;/p&gt;

&lt;p&gt;绕了半天还是回归正题，从零搭建PHP7开发环境：&lt;/p&gt;

&lt;h4 id=&#34;初始化虚拟环境&#34;&gt;初始化虚拟环境&lt;/h4&gt;

&lt;p&gt;这里假设你已经在本机安装好了VirtualBox+Vagrant，进入自己的想要存放环境的目录并在终端下执行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir trusty64 &amp;amp;&amp;amp; cd trusty64 # 创建并进入存放虚拟机的目录
vagrant init ubuntu/trusty64 # 使用Vagrant载入Ubuntu 14.04的box文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令会从外网下载Ubuntu 14.04的box文件，所以会比较慢，需要耐心等待。执行成功后编辑trusty64目录下的Vagrantfile配置文件来修改一些虚拟机的配置。&lt;/p&gt;

&lt;p&gt;由于网络原因box文件的下载可能出错，所以我这里提供我已下载的&lt;a href=&#34;http://pan.baidu.com/s/1o8wWWqQ&#34;&gt;Vagrant Ubuntu 14.04 Box&lt;/a&gt;文件给大家，可以直接在&lt;code&gt;trusty64&lt;/code&gt;目录下使用如下命令载入:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vagrant box add phpdev ubuntu-trusty64-20170831.box
vagrant init
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;调整虚拟机配置&#34;&gt;调整虚拟机配置&lt;/h5&gt;

&lt;p&gt;我习惯将配置文件中&lt;code&gt;config.vm.box_check_update = true&lt;/code&gt;修改为&lt;code&gt;config.vm.box_check_update = false&lt;/code&gt;，这样每次启动虚拟机就不会检查box文件是否有更新了。&lt;/p&gt;

&lt;p&gt;Vagrant 默认是使用端口映射方式将虚拟机的端口映射本地从而实现类似 &lt;a href=&#34;http://localhost:80&#34;&gt;http://localhost:80&lt;/a&gt; 这种访问方式，我更喜欢以固定IP的方式访问虚拟机，修改配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.vm.network :private_network, ip: &amp;quot;192.168.99.64&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样启动虚拟机后我们就能用 192.168.99.64 访问这台机器了，你可以把IP改成其他地址，只要冲突就行。&lt;/p&gt;

&lt;p&gt;默认Vagrant是把当前目录即&lt;code&gt;trusty64&lt;/code&gt;映射到虚拟机的&lt;code&gt;/vagrant&lt;/code&gt;目录下，你可以改变这个配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.vm.synced_folder &#39;.&#39;, &#39;/vagrant&#39;, disabled: true
config.vm.synced_folder &amp;quot;./PHPCode&amp;quot; , &amp;quot;/code&amp;quot;, :mount_options =&amp;gt; [&amp;quot;dmode=777&amp;quot;, &amp;quot;fmode=666&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面第一行关闭默认的目录映射，第二行将当前目录下的&lt;code&gt;PHPCode&lt;/code&gt;映射到虚拟机的&lt;code&gt;/code&lt;/code&gt;目录下。&lt;/p&gt;

&lt;h5 id=&#34;启动虚拟机&#34;&gt;启动虚拟机&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vagrant up # 启动虚拟机
vagrant ssh # ssh登陆虚拟机
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，现在咱们就有了一个纯净的Ubuntu 14.04的虚拟环境，接下来开始配置开发环境吧。&lt;/p&gt;

&lt;h4 id=&#34;配置开发环境&#34;&gt;配置开发环境&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo su # 切换为root用户
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先切换为root用户，因为后面有些安装步骤需要用到超级用户权限，我们在本地虚拟机配置开发环境对于安全性的要求没那么严格，所以这里直接切换成root用户减少麻烦。&lt;/p&gt;

&lt;h5 id=&#34;安装nginx&#34;&gt;安装Nginx&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get update # 更新软件源
apt-get install nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成之后在本机直接访问&lt;code&gt;http://192.168.99.64/&lt;/code&gt;，可以看到&lt;code&gt;Welcome to nginx!&lt;/code&gt;的页面表示nginx安装成功。&lt;/p&gt;

&lt;h4 id=&#34;编译安装php&#34;&gt;编译安装PHP&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get install build-essential libtool libpcre3 libpcre3-dev openssl libssl-dev
apt-get install libxml2-dev libcurl4-gnutls-dev libjpeg-dev libpng-dev libmcrypt-dev libreadline6 libreadline6-dev libfreetype6-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装一些编译要用到的包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ln -s /lib/x86_64-linux-gnu/libssl.so.1.0.0 /usr/lib/libssl.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决缺少了openssl的问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tar zxvf php-7.1.9.tar.gz
cd php-7.1.9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载PHP7的源码包，并解压。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --enable-fpm --with-fpm-user=www-data --with-fpm-group=www-data --with-mysqli --with-pdo-mysql --with-iconv-dir --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --enable-mbregex --enable-mbstring --with-mcrypt --enable-ftp --with-gd --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --disable-fileinfo --enable-maintainer-zts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置PHP编译选项。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make # 编译
make install # 安装
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样PHP将被安装到&lt;code&gt;/usr/local/php&lt;/code&gt;目录，编辑&lt;code&gt;/etc/enviornment&lt;/code&gt;， 将&lt;code&gt;/usr/local/php/bin&lt;/code&gt;添加到&lt;code&gt;PATH&lt;/code&gt; 变量，然后在终端执行&lt;code&gt;source /etc/environment&lt;/code&gt;更新环境变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp &amp;lt;php-source-dir&amp;gt;/php.ini-development /usr/local/php/etc/php.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置php.ini文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;php -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证PHP安装成功。&lt;/p&gt;

&lt;h4 id=&#34;配置php-fpm&#34;&gt;配置PHP-FPM&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf
cp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拷贝创建FPM配置文件，并修改&lt;code&gt;/usr/local/php/etc/php-fpm.d/www.conf&lt;/code&gt;部分配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; listen = 127.0.0.1:9000
listen = /var/run/php-fpm.sock
; unix socket

listen.owner = www-data
listen.group = www-data
listen.mode = 0660
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;初始化php-fpm服务脚本&#34;&gt;初始化PHP-FPM服务脚本&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp &amp;lt;source-dir&amp;gt;/sapi/fpm/init.d.php-fpm.in /etc/init.d/php-fpm
chmod 755 /etc/init.d/php-fpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://php.net/manual/en/install.fpm.php&#34;&gt;FPM Installation and Configuration&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;修改部分&lt;code&gt;/etc/init.d/php-fpm&lt;/code&gt;为如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prefix=
exec_prefix=
php_fpm_BIN=/usr/local/php/sbin/php-fpm
php_fpm_CONF=/usr/local/php/etc/php-fpm.conf
php_fpm_PID=/var/run/php-fpm.pid
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;启动php-fpm服务&#34;&gt;启动PHP-FPM服务&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/etc/init.d/php-fpm start # start php-fpm
# /etc/init.d/php-fpm stop
# /etc/init.d/php-fpm reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑&lt;code&gt;/etc/rc.local&lt;/code&gt;文件，在开机启动中加入PHP-FPM服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/etc/init.d/php-fpm start
···
exit 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此PHP-FPM配置成功。&lt;/p&gt;

&lt;h4 id=&#34;创建phpinfo-脚本&#34;&gt;创建phpinfo()脚本&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim /etc/nginx/sites-available/trusty64
ln -s /etc/nginx/sites-available/trusty64 /etc/nginx/sites-enabled/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建Nginx虚拟主机配置文件，并在中输入一下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
        listen 80;
        server_name trusty64.local; # 设置域名
        charset UTF-8;
        # 配置访问日志和错误日志
        access_log /var/log/trusty64-access.log;
        error_log /var/log/trusty64-error.log;
        # 站点根目录
        root /code/www/trusty64/public;

        index index.php index.html;

        location = /favicon.ico {
                log_not_found off;
                access_log off;
        }

        location ~ \.php$ {
                #fastcgi_pass   127.0.0.1:9000;
                fastcgi_pass   unix:/var/run/php-fpm.sock;
                fastcgi_index  index.php;
                fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_read_timeout 5000;
                include        fastcgi_params;
        }

        location ~ /\.ht {
                deny all;
        }

        # Prevents caching of css/less/js/images, only use this in development
        location ~* \.(css|less|js|jpg|png|gif)$ {
                add_header Cache-Control &amp;quot;no-cache, no-store, must-revalidate&amp;quot;; 
                add_header Pragma &amp;quot;no-cache&amp;quot;;
                expires 0;
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在虚拟机&lt;code&gt;/code/www/trusty64/public&lt;/code&gt;目录（位于映射的共享目录下）下创建&lt;code&gt;index.php&lt;/code&gt;，输入一下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
    phpinfo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启nginx，使配置的虚拟主机生效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;service nginx restart #
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改本机（不是虚拟机）的&lt;code&gt;/etc/hosts&lt;/code&gt;文件添加&lt;code&gt;trusty64.local&lt;/code&gt;的域名解析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;192.168.99.64 trusty64.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开本机浏览器访问&lt;code&gt;http://trusty64.local/&lt;/code&gt;可以看到&lt;code&gt;phpinfo()&lt;/code&gt;的输出，Nginx+PHP-FPM的开发环境已配置成功。&lt;/p&gt;

&lt;h4 id=&#34;安装mysql&#34;&gt;安装Mysql&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get install mysql-server mysql-client
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意在提示时输入root密码，安装完成后登陆Mysql为本机配置数据库访问权限。&lt;/p&gt;

&lt;p&gt;修改Mysql配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim /etc/mysql/my.cnf
# 把bind-address参数的值改成你的内/外网IP或0.0.0.0,或者直接注释掉这行.
# 重启Mysql使配置生效
service mysql stop
service mysql start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登陆Mysql为本机IP添加访问权限。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mysql -u root -p

mysql&amp;gt; use mysql;
mysql&amp;gt; update user set host=&#39;192.168.99.1&#39; where user=&#39;root&#39;;
mysql&amp;gt; flush privileges;
mysql&amp;gt; select user,host from user;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以直接使用本机的数据库管理工具如&lt;code&gt;Navicat&lt;/code&gt;连接&lt;code&gt;192.168.99.64&lt;/code&gt;访问和管理虚拟机上的Mysql。&lt;/p&gt;

&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;

&lt;p&gt;至此我们在Vagrant的Ubuntu 14.04下搭建了LNMP的开发环境，可以在本机上直接编辑映射的共享目录下的脚本文件，通过虚拟来进行测试，做到开发与测试环境隔离，不必担心在本地搭建过多的服务引起的混乱。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP面向对象笔记</title>
      <link>https://madiks.github.io/post/php-oop-note/</link>
      <pubDate>Mon, 23 May 2016 20:12:23 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/php-oop-note/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;阅读《PHP核心技术与最佳实践》对PHP面向对象相关知识的总结、整理与记录。&lt;/p&gt;

&lt;h3 id=&#34;面向对象-oop&#34;&gt;面向对象 OOP&lt;/h3&gt;

&lt;p&gt;面向对象程序设计（Object-Oriented Programming，OOP）是一种程序设计范性，同时也是一种程序开发方法。它将对象作为程序的基本单元，将程序和数据封装其中，以提代码的&lt;strong&gt;重用性&lt;/strong&gt;、&lt;strong&gt;灵活性&lt;/strong&gt;和&lt;strong&gt;可扩展性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;面向对象的核心思想是对象、封装、可重用和可扩展性。&lt;/p&gt;

&lt;p&gt;面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想（面向过程）刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。&lt;/p&gt;

&lt;p&gt;通常，OOP被理解为一种将程序分解为封装数据及相关操作的模块而进行的编程方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类是对象的抽象组织，对象是类的具体存在。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;php对象的本质&#34;&gt;PHP对象的本质&lt;/h3&gt;

&lt;p&gt;先看PHP5中变量的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#zend/zend.h

typedef union _zvalue_value {
    long lval; //整形
    double dval; //浮点数
    struct {
        char *val;
        int len;
    } str; //字符串
    HashTable *ht; //数组
    zend_object_value obj; //对象
} zvalue_value;

struct _zval_struct {
	/* Variable information */
	zvalue_value value;		/* value */
	zend_uint refcount__gc;
	zend_uchar type;	/* active type */
	zend_uchar is_ref__gc;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从源码可知php对象的类型是zend_object_value，接下来看它是如何实现的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#zend/zend.h

typedef struct _zend_object {
    zend_class_entry *ce; //类指针，指向对象对应的类
    HashTable *properties; //存放对象的属性表
    HashTable *guards; 
    /* protects from __get/__set ... recursion */
} zend_object;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PHP对象：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;属性数组（哈希表）&lt;/li&gt;
&lt;li&gt;类指针

&lt;ul&gt;
&lt;li&gt;类属性&lt;/li&gt;
&lt;li&gt;静态属性&lt;/li&gt;
&lt;li&gt;类常量&lt;/li&gt;
&lt;li&gt;标准方法&lt;/li&gt;
&lt;li&gt;魔术方法&lt;/li&gt;
&lt;li&gt;自定义方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对象也是一种普通的变量，不同的是其携带了对象的属性表和类的入口指针。&lt;/p&gt;

&lt;p&gt;于是可以总结PHP中对象和类的概念以及二者之间的关系：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;类是定义一系列属性和操作的模版，而对象则把属性进行具体化，然后交给类处理&lt;/li&gt;
&lt;li&gt;对象就是数据，本身不包含方法。但是对象有一个“指针”指向这个类，类里包含方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;类常量&#34;&gt;类常量&lt;/h3&gt;

&lt;p&gt;可以把在类中始终保持不变的值定义为常量。可以使用self（内部）或者类名／对象（外部）加&lt;code&gt;::&lt;/code&gt;来访问类常量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;class MyClass {
    const constant = &#39;constant value&#39;;

    function showConstant() {
        echo  self::constant . &amp;quot;\n&amp;quot;;
    }
}
var_dump(MyClass::constant);
$obj = new MyClass();
var_dump($obj::constant);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;魔术方法&#34;&gt;魔术方法&lt;/h3&gt;

&lt;p&gt;PHP魔术方法是以两个下划线&amp;rdquo;__&amp;ldquo;开头，具有特殊作用的方法。&lt;/p&gt;

&lt;p&gt;__construct() // 构造方法&lt;/p&gt;

&lt;p&gt;__destruct() // 析构方法&lt;/p&gt;

&lt;p&gt;PHP中的“重载”是指动态地创建类属性和方法：&lt;/p&gt;

&lt;p&gt;属性“重载”，当访问／设置的属性未定义／不可见时，PHP会自动调用对应的魔术方法&lt;/p&gt;

&lt;p&gt;__get($name)&lt;/p&gt;

&lt;p&gt;__set($name, $value)&lt;/p&gt;

&lt;p&gt;方法“重载”，当访问／设置的方法未定义／不可见时，PHP会自动调用对应的魔术方法，从而可以实现方法的动态创建&lt;/p&gt;

&lt;p&gt;__call($func_name, $parameters)
__callStatic($func_name, $parameters)&lt;/p&gt;

&lt;p&gt;__toString()&lt;/p&gt;

&lt;h3 id=&#34;php面向对象特性&#34;&gt;PHP面向对象特性&lt;/h3&gt;

&lt;p&gt;通常，OOP被理解为一种将程序分解为封装数据及相关操作的模块而进行的编程方式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;封装（Encapsulation），通过类来组织代码和限定数据访问权限将类与其外部世界划清界限，内外隔离来形成代码模块，让程序的结构更加清晰可理解&lt;/li&gt;
&lt;li&gt;继承（Inheritance），对类进行复用和扩展&lt;/li&gt;
&lt;li&gt;多态（Polymorphism），是指由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应。它真正的意义在于：&lt;strong&gt;实际开发中，只要关心一个接口或基类的编程，而不必关心一个对象所属的具体类&lt;/strong&gt;，同一类型（基类／接口），不同结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码复用分为继承和组合，继承是一种“是、像”的关系，而组合是一种“需要”的关系。&lt;/p&gt;

&lt;p&gt;耦合是软件结构内不同模块之间互相连接程度的度量，解耦就是要解除模块与模块间的依赖。&lt;/p&gt;

&lt;p&gt;PHP中的抽象类与接口：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;接口，多继承，只能声明 public 的方法，可以声明常量变量但不推荐这么做。接口是类与类之间的“协议”，定义了类的规范，为抽象而生。但是PHP的接口有两个不足：一是没有契约限制，使用时不做检查，二是缺少足够的内部接口。&lt;/li&gt;
&lt;li&gt;抽象类，单继承，可以声明各种类型成员变量及类常量，也可以定义非抽象方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;抽象类一般用于紧密相关的事物，而接口则用于事物的相同行为。抽象类核心是类及其行为，接口的核心是相同行为。如果必须从多个来源继承行为，就使用接口。&lt;/p&gt;

&lt;h3 id=&#34;反射-reflecton&#34;&gt;反射 Reflecton&lt;/h3&gt;

&lt;p&gt;反射，直观的理解就是根据到达地找到出发地和来源，探测类／对象的内部结构。可用于对文件里的类进行扫描来生产文档和拦截和修改方法的运行实现动态代理。&lt;/p&gt;

&lt;h3 id=&#34;异常-exception-与错误处理-error-handle&#34;&gt;异常（Exception）与错误处理（Error Handle）&lt;/h3&gt;

&lt;p&gt;PHP异常机制有不足，大部分情况无法自动抛出异常，一般只有手动抛出后才能捕获异常，但这也不影响异常机制的使用。下面三种情况会用到异常处理机制。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对程序的悲观预测，有无法预测／不可避免的情况发生&lt;/li&gt;
&lt;li&gt;程序的需要和对业务的关注，业务很重要，及早处理异常&lt;/li&gt;
&lt;li&gt;语言级别的健壮性要求，作为一种程序的补救措施及时catch和处理异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PHP错误就是会使脚本运行不正常的情况。大致的错误级别：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;deprecated&lt;/li&gt;
&lt;li&gt;notice&lt;/li&gt;
&lt;li&gt;warning&lt;/li&gt;
&lt;li&gt;fatal error&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;error_reporting — 设置应该报告何种 PHP 错误
php.ini
// 显示错误
display_errors = Off
// 记录错误日志
log_errors = On
error_log = /var/log/php_errors.log&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;error_reporting(0); // 关闭所有PHP错误报告
error_reporting(-1); // 报告所有 PHP 错误
error_reporting(E_ALL);

error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);
error_reporting(E_ALL ^ E_NOTICE); // 除了 E_NOTICE，报告其他所有错误
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接管错误和异常处理，获得更多灵活性：
set_error_handler — 设置用户自定义的错误处理函数
restore_error_handler — 还原之前的错误处理函数&lt;/p&gt;

&lt;p&gt;以下级别的错误不能由用户定义的函数来处理： E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，和在 调用 set_error_handler() 函数所在文件中产生的大多数 E_STRICT。&lt;/p&gt;

&lt;p&gt;set_exception_handler — 设置用户自定义的异常处理函数
restore_exception_handler — 恢复之前定义过的异常处理函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;mixed set_error_handler ( callable $error_handler [, int $error_types = E_ALL | E_STRICT ] )
bool restore_error_handler ( void )

callable set_exception_handler ( callable $exception_handler )
bool restore_exception_handler ( void )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;register_shutdown_function — 注册一个会在php中止时执行的函数
// 注册一个 callback ，它会在脚本执行完成或者 exit() 后被调用。&lt;/p&gt;

&lt;h3 id=&#34;面向对象设计原则&#34;&gt;面向对象设计原则&lt;/h3&gt;

&lt;p&gt;设计模式主要探讨的是类与类之间的关系。&lt;/p&gt;

&lt;p&gt;面相对象五大设计原则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单一职责原则&lt;/li&gt;
&lt;li&gt;接口隔离原则&lt;/li&gt;
&lt;li&gt;开放-封闭原则&lt;/li&gt;
&lt;li&gt;替换原则&lt;/li&gt;
&lt;li&gt;依赖倒置原则&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;单一职责原则（Single Responsibility Principle），它有两个含义：一个是避免相同的职责分散到不同的类中，另一个是避免一个类承担太多职责。可以减少耦合提高复用，是最简单也是最难做好的职责之一。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;工厂模式，根据不同参数，生成不同的实例化对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接口隔离原则（Interface Segregation Principle），一个类对另一个类的依赖性应该是建立在最小的接口上的，接口的内容应该服务于一个近似不可分割的小模块。“接口隔离”其实就是定制化服务设计的原则，服务（接口）尽量小、自成一体与外部隔离，使用多重继承实现对不同接口的组合，从而对外提供组合功能——达到“按需提供服务”。&lt;/p&gt;

&lt;p&gt;开放-封闭原则（Open-Close Principle），开放：模块的行为必须是开放的、支持扩展的，而不是僵化的。封闭：在对模块功能进行扩展时不应该影响或大规模影响已有的程序模块。概括一下就是：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。&lt;/p&gt;

&lt;p&gt;实现开放-封闭原则的核心就是&lt;strong&gt;对抽象编程&lt;/strong&gt;，而不对具体编程，因为抽象稳定。例如，让类依赖于固定的抽象类，这样的修改就是封闭的；通过面相对象的继承和多态机制，可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。具体实践中应该：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在设计方面充分应用“抽象”和“封装”思想，抽象出不变的部分将其封装成模块。&lt;/li&gt;
&lt;li&gt;在系统功能编程实现方面应用依赖抽象（抽象类／接口）的编程。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;替换原则（Liskov Substitution Principle），子类型必须能够替换掉它们的父类型、并出现在父类能够出现的任何地方。简单来说就是：子类必须能够替换成它们的基类。&lt;/p&gt;

&lt;p&gt;如何遵守该原则呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;父类的方法都要在子类中实现或者重写，并且派生类只实现其抽象类中声明的方法，而不应当给出多余的方法定义或者实现。&lt;/li&gt;
&lt;li&gt;在客户端程序中只应该使用父类对象而不应当直接使用子类对象，这样可以实现运行期绑定（动态多态）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;依赖倒置原则（Dependence Inversion Principle），简单讲就是将依赖关系倒置为依赖接口，&lt;strong&gt;依赖倒置的核心是解耦&lt;/strong&gt;，具体概念如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;上层模块不应该依赖于下层模块，它们共同依赖于一个抽象；例如：父类不能依赖子类，它们都要依赖抽象类。&lt;/li&gt;
&lt;li&gt;抽象不能依赖于具体，具体应该要依赖于抽象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其实，面相过程也好，面向对象也好，目的只有两个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;功能实现&lt;/li&gt;
&lt;li&gt;代码维护和扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;单例模式 Singleton&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只能有一个实例&lt;/li&gt;
&lt;li&gt;必须自行创建这个实例&lt;/li&gt;
&lt;li&gt;必须给其他对象提供这一实例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PHP单例模式的优缺点：虽然PHP每次执行完页面都是会从内存中清理掉所有的资源。因而PHP中的单例实际每次运行都是需要重新实例化的，但PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免（在单次请求中）大量的new操作。因为每一次new操作都会消耗系统和内存的资源。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>php自定义Warning的输出信息</title>
      <link>https://madiks.github.io/post/php-custom-warning-message/</link>
      <pubDate>Tue, 30 Dec 2014 21:10:40 +0800</pubDate>
      
      <guid>https://madiks.github.io/post/php-custom-warning-message/</guid>
      <description>

&lt;h3 id=&#34;php自定义warning的输出信息&#34;&gt;php自定义Warning的输出信息&lt;/h3&gt;

&lt;p&gt;前几天公司平台接入了新的合作商，数据抓取服务一直没问题，到今天有一本书一直报错，查看log发现Warning,出错是由于导致xml解析错误。想到输出一下具体的bookid和chapter_id来查看到底是哪本书哪个章节的问题。&lt;/p&gt;

&lt;p&gt;直接想到的方案是try catch在出错的时候输出bookid和chapter_id,但是发现php try catch无法处理Warning错误，于是Google了php如何catch warning，在stackoverflow上找到了如下方法：
&lt;a href=&#34;http://stackoverflow.com/questions/1241728/can-i-try-catch-a-warning&#34;&gt;http://stackoverflow.com/questions/1241728/can-i-try-catch-a-warning&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;大致是通过 set_error_handler来自定义处理Warning的方法，在其中抛出一个异常然后再try catch它输出bookid和chapter_id，基本照抄给的实例于是如下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;set_error_handler(function($errno, $errstr, $errfile, $errline, array $errcontext) {
  // error was suppressed with the @-operator
     if (0 === error_reporting()) {
         return false;
     }
     throw new ErrorException($errstr, 0, $errno, $errfile, $errline);
}, E_WARNING);
try{
  $chapter_content = simplexml_load_string($chaptercontent_xml);
} catch (Exception $e) {
    echo &amp;quot;Caught exception: bookid = $id , chapter_id = $chapter_id &amp;quot;,  $e-&amp;gt;getMessage(), &amp;quot;\n&amp;quot;;
    exit();
}
restore_error_handler();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释：使用set_error_handler来接管warning的处理，在其回调函数中抛出一个Exception,然后就可以try catch了，最后调用restore_error_handler();来撤销你设置的error_handler从而使其不影响后续的代码。&lt;/p&gt;

&lt;p&gt;思考：这样改完后确实得到了bookid和chapter_id，但是有没有别的更简单方法来实现，其实我最本质的需求就是要自定义输出的Warning消息使其在输出错误的时候带上bookid和chapter_id上面的方法虽然解决了这个问题但是绕了一个大圈。查看php手册上set_error_handler的详细用法发现：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;handler的第五个可选参数，errcontext， 是一个指向错误发生时活动符号表的 array。 也就是说，errcontext 会包含错误触发处作用域内所有变量的数组。 用户的错误处理程序不应该修改错误上下文（context）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们在此处直接用errcontext直接输出要的信息即可，于是有了下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;set_error_handler(function($errno, $errstr, $errfile, $errline, array $errcontext){
  // error was suppressed with the @-operator
  if (0 === error_reporting()) {
     return false;
  }
  echo &amp;quot;Caught Waring:bookid=$errcontext[bookid],chapter_id=$errcontext[chapter_id] Waring Message:&amp;quot;,$errstr,&#39; in &#39;,$errfile,&#39; on line &#39;,$errline,&amp;quot;\n&amp;quot;;
}, E_WARNING);
$chapter_content = simplexml_load_string($chaptercontent_xml);
restore_error_handler();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释：直接在set_error_handler组织和输出错误信息即可完成自定义Warning错误信息的输出，这样简单了很多，加上这段代码后以后如果出问题直接去log里面查找就可拿到所需的信息，定位到问题所在。&lt;/p&gt;

&lt;p&gt;总结：在解决完一个问题是最好多想想这个问题的本质，有没有更好的解决方案，这才能不断进步。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>